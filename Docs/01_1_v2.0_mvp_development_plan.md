# Switchboard Plus v2.0 MVP - 개발 계획서

## 📋 1. 문서 개요

**프로젝트**: Switchboard Plus v2.0 MVP  
**목적**: 언리얼엔진 nDisplay 원격 제어를 위한 통합 웹 시스템  
**개발 도구**: Cursor AI 협업 중심  
**배포 방식**: 전용 서버 + 웹 접속  
**개발 기간**: 8-10주 (MVP 완성)

> 🎯 **핵심 철학**: 완벽한 기능보다 **실제 동작하는 시스템** 우선
> ✨ **MVP 전략**: 핵심 기능만으로 v2.0 완성 → v2.1에서 고급 기능 추가

---

## 🏗️ 2. 시스템 아키텍처 (단순화)

### 2.1 MVP 서버 구조

```
🖥️ Switchboard Plus Server (1대)
┌─────────────────────────────────────┐
│  포트 8000 (HTTP 접속)              │
├─────────────────────────────────────┤
│ ✅ Express 서버 (기본 API)          │
│ ✅ React UI (정적 파일)             │  
│ ✅ Socket.io (기본 실시간 통신)     │
│ ✅ SQLite 데이터베이스              │
└─────────────────────────────────────┘
              ↓ HTTP API
┌─────────────────────────────────────┐
│  Display PC들 (N대)                 │
├─────────────────────────────────────┤
│ ✅ Python 클라이언트                │
│ ✅ 언리얼엔진 nDisplay              │  
│ ✅ 수동 IP 설정                     │
└─────────────────────────────────────┘
```

### 2.2 MVP vs 완전 기능 비교

| 구분 | MVP (v2.0) | 고급 기능 (v2.1+) |
|------|-----------|-------------|
| **보안** | 기본 CORS만 | API 키, Rate Limiting |
| **성능** | 기본 동작 확보 | 캐싱, 최적화 |
| **모니터링** | 연결 상태만 | 상세 메트릭 |
| **에러 처리** | 기본 try-catch | 자동 재시도, 복구 |
| **UI/UX** | 기본 기능 동작 | 다크테마, 반응형 |

---

## 🚀 3. 개발 로드맵 (4단계) - MVP 완성

### Phase 1: 기본 서버 + 간단한 클라이언트 관리 (Week 1-3) 🏠 **로컬 개발**

#### 4.4 클라이언트 등록 및 연결 방식 (서버 주도적)

**핵심 원칙**: 서버가 주도적으로 클라이언트를 관리하는 방식

```
1. 클라이언트 등록 (수동)
   웹 UI → 서버에 클라이언트 정보 등록 → DB 저장

2. 서버 주도적 연결 확인
   서버가 DB의 클라이언트 목록을 기반으로 주기적으로 연결 확인
   
3. 연결 확인 프로세스
   서버 → 클라이언트에게 메시지 전송 → 클라이언트 응답 → 상태 업데이트
```

**구체적 구현 방식**:

```javascript
// 서버 측: 클라이언트 연결 확인 시스템
class ClientConnectionManager {
  constructor() {
    this.clients = new Map();
    this.checkInterval = 30000; // 30초마다 확인
  }
  
  // 1. 등록된 클라이언트 목록 가져오기
  async getRegisteredClients() {
    return new Promise((resolve, reject) => {
      db.all('SELECT * FROM clients', (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });
  }
  
  // 2. 클라이언트 연결 상태 확인
  async checkClientConnection(client) {
    try {
      // HTTP 요청으로 클라이언트 상태 확인
      const response = await fetch(`http://${client.ip_address}:${client.port}/health`, {
        timeout: 5000
      });
      
      if (response.ok) {
        return { status: 'online', lastSeen: new Date() };
      } else {
        return { status: 'offline', lastSeen: client.last_seen };
      }
    } catch (error) {
      return { status: 'offline', lastSeen: client.last_seen };
    }
  }
  
  // 3. 주기적 연결 확인
  startConnectionMonitoring() {
    setInterval(async () => {
      const clients = await this.getRegisteredClients();
      
      for (const client of clients) {
        const status = await this.checkClientConnection(client);
        await this.updateClientStatus(client.id, status);
      }
    }, this.checkInterval);
  }
  
  // 4. 클라이언트 상태 업데이트
  async updateClientStatus(clientId, status) {
    return new Promise((resolve, reject) => {
      db.run(
        'UPDATE clients SET status = ?, last_seen = ? WHERE id = ?',
        [status.status, status.lastSeen, clientId],
        (err) => {
          if (err) reject(err);
          else resolve();
        }
      );
    });
  }
}
```

**클라이언트 측: 응답 시스템**:

```python
# client/health_endpoint.py
from flask import Flask, jsonify
import datetime

app = Flask(__name__)

@app.route('/health')
def health_check():
    """서버의 연결 확인 요청에 응답"""
    return jsonify({
        'status': 'ok',
        'client_name': 'Display_01',
        'timestamp': datetime.datetime.now().isoformat(),
        'uptime': get_system_uptime()
    })

@app.route('/execute', methods=['POST'])
def execute_command():
    """서버로부터 명령 실행 요청 처리"""
    data = request.json
    command = data.get('command')
    
    # 명령 실행
    result = execute_unreal_command(command)
    
    return jsonify({
        'status': 'success' if result else 'failed',
        'result': result
    })

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8081)
```

**장점**:
- ✅ 클라이언트가 서버를 계속 찾을 필요 없음
- ✅ 서버가 주도적으로 관리하므로 안정적
- ✅ DB 기반으로 등록된 클라이언트만 관리
- ✅ 네트워크 부하 최소화

**구현 순서**:
1. 웹 UI에서 클라이언트 수동 등록
2. 서버에서 등록된 클라이언트 목록 관리
3. 주기적 연결 확인 시스템 구현
4. 클라이언트 응답 시스템 구현
5. 실시간 상태 업데이트

```
목표: 동작하는 서버 + 클라이언트 등록 기능
핵심 기능:
- Express 서버 + SQLite
- 클라이언트 수동 등록 API  
- 서버 주도적 연결 확인 시스템
- 클라이언트 응답 시스템
- 기본 Socket 통신
- 간단한 웹 UI (정적)

성공 기준:
✅ http://localhost:8000 접속 가능
✅ 클라이언트 추가/목록 조회 가능  
✅ 서버가 등록된 클라이언트 연결 상태 확인 가능
✅ 클라이언트 응답 시스템 동작 확인
✅ 기본 데이터 저장/불러오기
```

### Phase 2: 웹 UI + 프리셋 기능 (Week 4-6) 🏠 **로컬 개발**
```
목표: React UI + 프리셋 생성/실행
핵심 기능:
- React 기반 관리 인터페이스
- 프리셋 CRUD (생성/수정/삭제)
- 그룹 기본 기능
- 실시간 UI 업데이트

성공 기준:
✅ 프리셋 생성하고 저장 가능
✅ 클라이언트 목록 실시간 표시
✅ 기본적인 그룹 관리 가능
```

### Phase 3: Python 클라이언트 + 실제 연결 (Week 7-8) 🌐 **멀티 PC 전환**
```
목표: 실제 nDisplay 제어 동작
핵심 기능:
- Python 클라이언트 개발
- 서버-클라이언트 통신
- 언리얼엔진 실행 명령
- 기본 상태 모니터링

성공 기준:
✅ 웹에서 프리셋 클릭 → 언리얼엔진 실행
✅ 여러 PC에서 동시 실행 가능
✅ 클라이언트 온라인/오프라인 상태 표시
```

### Phase 4: 배포 + 문서화 (Week 9-10) 🚀 **실제 운영**
```
목표: 설치 가능한 완성품
핵심 기능:
- 실행 파일 빌드
- 설치 가이드 작성
- 기본 문제 해결 문서
- 사용자 테스트

성공 기준:
✅ 다른 사람이 설치해서 사용 가능
✅ 기본적인 nDisplay 운영 가능
✅ 문제 발생 시 해결 방법 제공
```

---

## 🔧 4. Phase 1: 기본 서버 (MVP)

### 4.1 프로젝트 구조 (단순화)

```
switchboard-plus-v2/
├── package.json              # 루트 패키지
├── server/                   # 서버 (간단)
│   ├── app.js               # 메인 서버 파일
│   ├── routes/              # API 라우트
│   │   ├── clients.js       # 클라이언트 관리
│   │   ├── presets.js       # 프리셋 관리
│   │   └── groups.js        # 그룹 관리
│   ├── database.js          # SQLite 연결 (단순)
│   ├── socket.js            # Socket 이벤트 (기본)
│   └── public/              # React 빌드 파일
├── client/                  # Python 클라이언트
│   ├── main.py              # 메인 실행 파일
│   ├── config.json          # 설정 파일
│   └── setup.py             # 설정 도구
└── web-ui/                  # React UI
    ├── src/
    ├── package.json
    └── vite.config.js
```

### 4.2 데이터베이스 설계 (핵심만)

```sql
-- 클라이언트 테이블 (핵심 정보만)
CREATE TABLE clients (
    id INTEGER PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    ip_address VARCHAR(45) NOT NULL,
    port INTEGER DEFAULT 8081,
    status VARCHAR(50) DEFAULT 'offline',
    last_seen DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 그룹 테이블 (단순)
CREATE TABLE groups (
    id INTEGER PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 그룹-클라이언트 관계
CREATE TABLE group_clients (
    group_id INTEGER,
    client_id INTEGER,
    PRIMARY KEY (group_id, client_id)
);

-- 프리셋 테이블 (필수 정보만)
CREATE TABLE presets (
    id INTEGER PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    command TEXT NOT NULL,
    target_group_id INTEGER,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 기본 인덱스만
CREATE INDEX idx_clients_status ON clients(status);
CREATE INDEX idx_clients_ip ON clients(ip_address);
```

### 4.3 API 구조 (단순화)

```javascript
// app.js - 메인 서버 (한 파일에 모든 기능)
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const sqlite3 = require('sqlite3').verbose();
const path = require('path');

const app = express();
const server = http.createServer(app);
const io = socketIo(server);

// 기본 미들웨어 (최소한)
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// SQLite 연결 (단순)
const db = new sqlite3.Database('database.sqlite');

// 기본 API들
app.get('/api/clients', (req, res) => {
  db.all('SELECT * FROM clients ORDER BY name', (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(rows);
  });
});

app.post('/api/clients', (req, res) => {
  const { name, ip_address, port } = req.body;
  
  db.run(
    'INSERT INTO clients (name, ip_address, port) VALUES (?, ?, ?)',
    [name, ip_address, port || 8081],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ id: this.lastID, name, ip_address, port });
    }
  );
});

// 프리셋 API (기본)
app.get('/api/presets', (req, res) => {
  db.all('SELECT * FROM presets ORDER BY name', (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(rows);
  });
});

app.post('/api/presets', (req, res) => {
  const { name, command, target_group_id } = req.body;
  
  db.run(
    'INSERT INTO presets (name, command, target_group_id) VALUES (?, ?, ?)',
    [name, command, target_group_id],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ id: this.lastID, name, command, target_group_id });
    }
  );
});

// 프리셋 실행 (핵심 기능)
app.post('/api/presets/:id/execute', (req, res) => {
  const presetId = req.params.id;
  
  // 프리셋 정보 가져오기
  db.get('SELECT * FROM presets WHERE id = ?', [presetId], (err, preset) => {
    if (err) return res.status(500).json({ error: err.message });
    if (!preset) return res.status(404).json({ error: 'Preset not found' });
    
    // 그룹의 클라이언트들에게 명령 전송
    const query = `
      SELECT c.* FROM clients c 
      JOIN group_clients gc ON c.id = gc.client_id 
      WHERE gc.group_id = ? AND c.status = 'online'
    `;
    
    db.all(query, [preset.target_group_id], (err, clients) => {
      if (err) return res.status(500).json({ error: err.message });
      
      // Socket으로 각 클라이언트에 명령 전송
      clients.forEach(client => {
        io.emit('execute_command', {
          client_name: client.name,
          command: preset.command
        });
      });
      
      res.json({ 
        message: 'Preset executed',
        target_clients: clients.length 
      });
    });
  });
});

// Socket 이벤트 (기본만)
io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);
  
  // 클라이언트 등록
  socket.on('register_client', (data) => {
    const { name } = data;
    
    db.run(
      'UPDATE clients SET status = ?, last_seen = ? WHERE name = ?',
      ['online', new Date(), name],
      (err) => {
        if (!err) {
          io.emit('client_status_changed', { name, status: 'online' });
        }
      }
    );
  });
  
  // 하트비트
  socket.on('heartbeat', (data) => {
    const { name } = data;
    
    db.run(
      'UPDATE clients SET last_seen = ? WHERE name = ?',
      [new Date(), name]
    );
  });
  
  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
  });
});

// 서버 시작
const PORT = 8000;
server.listen(PORT, () => {
  console.log(`🚀 Switchboard Plus MVP Server running on http://localhost:${PORT}`);
});
```

### 4.4 Phase 1 체크리스트 (MVP)

#### 4.4.1 서버 기본 (필수만)
- [x] Express 앱 생성 및 기본 설정
- [x] SQLite 데이터베이스 연결
- [x] 클라이언트 CRUD API (생성/조회/수정/삭제)
- [x] 프리셋 CRUD API
- [x] 그룹 기본 API
- [x] Socket.io 기본 연결

#### 4.4.2 핵심 기능 (동작 확인)
- [x] 클라이언트 수동 등록 가능
- [x] 프리셋 생성 및 저장 가능
- [x] 기본 그룹 관리 가능
- [x] Socket 연결 확인 가능
- [x] 데이터베이스 읽기/쓰기 동작

#### 4.4.3 테스트 (로컬만)
- [x] 서버 실행 확인 (http://localhost:8000)
- [x] Postman으로 API 테스트
- [x] 브라우저에서 API 호출 확인
- [x] 데이터베이스 파일 생성 확인

#### 4.4.4 문제 해결 준비
- [x] 기본 에러 로깅 (console.log)
- [x] API 에러 응답 표준화
- [x] 간단한 유효성 검사

---

## 🎨 5. Phase 2: 웹 UI (MVP)

### 5.1 React 구조 (단순화)

```
web-ui/src/
├── App.jsx                  # 메인 앱
├── components/
│   ├── ClientList.jsx       # 클라이언트 목록
│   ├── ClientCard.jsx       # 클라이언트 카드
│   ├── PresetList.jsx       # 프리셋 목록
│   ├── PresetForm.jsx       # 프리셋 생성 폼
│   ├── GroupList.jsx        # 그룹 목록
│   └── Header.jsx           # 상단 헤더
├── hooks/
│   ├── useApi.js            # API 호출 훅
│   └── useSocket.js         # Socket 연결 훅
├── services/
│   ├── api.js               # Axios 설정
│   └── socket.js            # Socket 클라이언트
└── main.jsx
```

### 5.2 핵심 컴포넌트 (기본 기능만)

#### App.jsx (메인)
```jsx
import React, { useState, useEffect } from 'react';
import './App.css';
import Header from './components/Header';
import ClientList from './components/ClientList';
import PresetList from './components/PresetList';
import GroupList from './components/GroupList';
import useApi from './hooks/useApi';
import useSocket from './hooks/useSocket';

function App() {
  const [clients, setClients] = useState([]);
  const [presets, setPresets] = useState([]);
  const [groups, setGroups] = useState([]);
  const { get, post } = useApi();
  const { socket, isConnected } = useSocket();

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      const [clientsData, presetsData, groupsData] = await Promise.all([
        get('/api/clients'),
        get('/api/presets'),
        get('/api/groups')
      ]);
      setClients(clientsData);
      setPresets(presetsData);
      setGroups(groupsData);
    } catch (error) {
      console.error('데이터 로드 실패:', error);
      alert('데이터를 불러오는데 실패했습니다.');
    }
  };

  const executePreset = async (presetId) => {
    try {
      await post(`/api/presets/${presetId}/execute`);
      alert('프리셋이 실행되었습니다!');
    } catch (error) {
      alert('프리셋 실행에 실패했습니다: ' + error.message);
    }
  };

  return (
    <div className="app">
      <Header isConnected={isConnected} />
      
      <div className="container">
        <div className="stats">
          <div className="stat">
            <span>전체 클라이언트: {clients.length}</span>
          </div>
          <div className="stat">
            <span>온라인: {clients.filter(c => c.status === 'online').length}</span>
          </div>
          <div className="stat">
            <span>프리셋: {presets.length}</span>
          </div>
        </div>

        <div className="main-grid">
          <div className="section">
            <h2>클라이언트 관리</h2>
            <ClientList 
              clients={clients} 
              onRefresh={loadData}
            />
          </div>

          <div className="section">
            <h2>프리셋 관리</h2>
            <PresetList 
              presets={presets}
              groups={groups}
              onExecute={executePreset}
              onRefresh={loadData}
            />
          </div>

          <div className="section">
            <h2>그룹 관리</h2>
            <GroupList 
              groups={groups}
              clients={clients}
              onRefresh={loadData}
            />
          </div>
        </div>
      </div>
    </div>
  );
}

export default App;
```

### 5.3 기본 스타일링 (CSS만)

```css
/* App.css - 기본 스타일만 */
.app {
  font-family: -apple-system, BlinkMacSystemFont, sans-serif;
  padding: 20px;
  background: #f5f5f5;
  min-height: 100vh;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
}

.stats {
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
  padding: 15px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.stat {
  font-weight: 600;
  color: #333;
}

.main-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
}

.section {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.section h2 {
  margin: 0 0 15px 0;
  color: #333;
  border-bottom: 2px solid #007bff;
  padding-bottom: 5px;
}

/* 버튼 스타일 */
button {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  margin: 2px;
}

.btn-primary {
  background: #007bff;
  color: white;
}

.btn-success {
  background: #28a745;
  color: white;
}

.btn-danger {
  background: #dc3545;
  color: white;
}

.btn-secondary {
  background: #6c757d;
  color: white;
}

/* 폼 스타일 */
.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 600;
}

.form-group input,
.form-group textarea,
.form-group select {
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
}

/* 클라이언트 카드 */
.client-card {
  border: 1px solid #ddd;
  border-radius: 6px;
  padding: 15px;
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.client-card.online {
  border-left: 4px solid #28a745;
}

.client-card.offline {
  border-left: 4px solid #dc3545;
  opacity: 0.7;
}

/* 프리셋 카드 */
.preset-card {
  border: 1px solid #ddd;
  border-radius: 6px;
  padding: 15px;
  margin-bottom: 10px;
}

.preset-actions {
  margin-top: 10px;
}
```

### 5.4 Phase 2 체크리스트 (MVP)

#### 5.4.1 기본 UI 컴포넌트
- [x] React 앱 생성 및 기본 구조
- [x] 클라이언트 목록 표시
- [x] 클라이언트 추가 폼
- [x] 프리셋 목록 표시
- [x] 프리셋 생성 폼
- [x] 그룹 기본 관리

#### 5.4.2 API 연동 (핵심 기능)
- [x] Axios로 API 호출
- [x] 데이터 CRUD 동작 확인
- [x] Socket으로 실시간 업데이트
- [x] 에러 처리 (alert 사용)

#### 5.4.3 사용성 (기본)
- [x] 직관적인 버튼 배치
- [x] 폼 유효성 검사 (기본)
- [x] 성공/실패 메시지 표시
- [x] 기본 CSS 스타일링

#### 5.4.4 테스트 (로컬)
- [x] 웹 브라우저에서 접속 확인
- [x] 클라이언트 추가/삭제 동작
- [x] 프리셋 생성/실행 동작
- [x] 실시간 업데이트 확인

---

## 🖥️ 6. Phase 3: Python 클라이언트 (MVP)

### 6.1 클라이언트 구조 (단순화)

```python
# main.py - 메인 클라이언트 (한 파일)
import json
import time
import requests
import subprocess
import websocket
import threading
from pathlib import Path

class SwitchboardClient:
    def __init__(self):
        self.config = self.load_config()
        self.server_url = f"http://{self.config['server_ip']}:{self.config['server_port']}"
        self.ws_url = f"ws://{self.config['server_ip']}:{self.config['server_port']}"
        self.running_processes = []
        self.ws = None
        
    def load_config(self):
        """설정 파일 로드 (간단한 JSON)"""
        try:
            with open('config.json', 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            # 기본 설정 생성
            default_config = {
                "client_name": "Display_01",
                "server_ip": "192.168.1.100",
                "server_port": 8000,
                "heartbeat_interval": 30
            }
            with open('config.json', 'w') as f:
                json.dump(default_config, f, indent=2)
            print("config.json 파일이 생성되었습니다. 설정을 수정한 후 다시 실행하세요.")
            exit(0)
    
    def register_with_server(self):
        """서버에 클라이언트 등록 (HTTP)"""
        try:
            response = requests.post(f"{self.server_url}/api/clients", json={
                "name": self.config["client_name"],
                "ip_address": self.get_local_ip(),
                "port": 8081
            }, timeout=10)
            
            if response.status_code in [200, 201]:
                print(f"✅ 서버에 등록 완료: {self.config['client_name']}")
                return True
            else:
                print(f"❌ 서버 등록 실패: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"❌ 서버 연결 실패: {e}")
            return False
    
    def connect_websocket(self):
        """WebSocket 연결 (기본)"""
        try:
            self.ws = websocket.WebSocketApp(
                self.ws_url,
                on_message=self.on_message,
                on_error=self.on_error,
                on_close=self.on_close,
                on_open=self.on_open
            )
            self.ws.run_forever()
        except Exception as e:
            print(f"WebSocket 연결 실패: {e}")
    
    def on_open(self, ws):
        """WebSocket 연결 시"""
        print("WebSocket 연결됨")
        
        # 클라이언트 등록
        ws.send(json.dumps({
            "type": "register_client",
            "name": self.config["client_name"]
        }))
    
    def on_message(self, ws, message):
        """서버에서 명령 수신"""
        try:
            data = json.loads(message)
            
            if data.get("type") == "execute_command":
                client_name = data.get("client_name")
                command = data.get("command")
                
                # 이 클라이언트에게 온 명령인지 확인
                if client_name == self.config["client_name"]:
                    print(f"명령 수신: {command}")
                    self.execute_command(command)
                    
        except Exception as e:
            print(f"메시지 처리 오류: {e}")
    
    def execute_command(self, command):
        """언리얼엔진 실행 (핵심 기능)"""
        try:
            print(f"언리얼엔진 실행 중: {command}")
            
            # 기존 프로세스 종료
            self.stop_all_processes()
            
            # 새 프로세스 시작
            process = subprocess.Popen(command, shell=True)
            self.running_processes.append(process)
            
            print("✅ 언리얼엔진 실행 성공")
            
        except Exception as e:
            print(f"❌ 언리얼엔진 실행 실패: {e}")
    
    def stop_all_processes(self):
        """모든 프로세스 중지"""
        for process in self.running_processes:
            try:
                process.terminate()
            except:
                pass
        self.running_processes = []
        print("🛑 모든 프로세스 중지")
    
    def send_heartbeat(self):
        """하트비트 전송 (기본)"""
        try:
            if self.ws:
                self.ws.send(json.dumps({
                    "type": "heartbeat",
                    "name": self.config["client_name"]
                }))
        except:
            pass
    
    def on_error(self, ws, error):
        print(f"WebSocket 오류: {error}")
    
    def on_close(self, ws, close_status_code, close_msg):
        print("WebSocket 연결 종료")
    
    def get_local_ip(self):
        """로컬 IP 주소 가져오기"""
        import socket
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.connect(("8.8.8.8", 80))
                return s.getsockname()[0]
        except:
            return "127.0.0.1"
    
    def run(self):
        """메인 실행"""
        print(f"🚀 Switchboard Plus Client 시작: {self.config['client_name']}")
        
        # 서버 등록
        if not self.register_with_server():
            print("서버 등록 실패. 5초 후 재시도...")
            time.sleep(5)
            return self.run()  # 재시도
        
        # WebSocket 연결 (백그라운드)
        ws_thread = threading.Thread(target=self.connect_websocket)
        ws_thread.daemon = True
        ws_thread.start()
        
        # 하트비트 루프
        try:
            while True:
                time.sleep(self.config.get('heartbeat_interval', 30))
                self.send_heartbeat()
                
        except KeyboardInterrupt:
            print("🛑 클라이언트 종료")
            self.stop_all_processes()

if __name__ == "__main__":
    client = SwitchboardClient()
    client.run()
```

### 6.2 설정 도구 (간단)

```python
# setup.py - 간단한 설정 도구
import json

def setup_client():
    print("🔧 Switchboard Plus Client 설정")
    print("=" * 40)
    
    # 기본값
    config = {
        "client_name": "Display_01",
        "server_ip": "192.168.1.100", 
        "server_port": 8000,
        "heartbeat_interval": 30
    }
    
    # 사용자 입력
    config["client_name"] = input(f"클라이언트 이름 ({config['client_name']}): ").strip() or config["client_name"]
    config["server_ip"] = input(f"서버 IP ({config['server_ip']}): ").strip() or config["server_ip"]
    
    port_input = input(f"서버 포트 ({config['server_port']}): ").strip()
    if port_input:
        config["server_port"] = int(port_input)
    
    # 저장
    with open('config.json', 'w') as f:
        json.dump(config, f, indent=2)
    
    print("\n✅ 설정 완료!")
    print("이제 main.py를 실행하세요.")

if __name__ == "__main__":
    setup_client()
```

### 6.3 Phase 3 체크리스트 (MVP)

#### 6.3.1 기본 통신 (핵심)
- [ ] HTTP로 서버에 클라이언트 등록
- [ ] WebSocket 연결 및 유지
- [ ] 명령 수신 및 처리
- [ ] 하트비트 전송 (30초마다)
- [ ] 기본 에러 처리

#### 6.3.2 언리얼엔진 제어 (핵심)
- [ ] subprocess로 언리얼엔진 실행
- [ ] 기존 프로세스 종료 후 새 실행
- [ ] 명령 실행 성공/실패 로깅
- [ ] 프로세스 상태 추적

#### 6.3.3 설정 관리 (기본)
- [ ] config.json 파일 생성/읽기
- [ ] 설정 도구 (setup.py)
- [ ] 기본값 제공
- [ ] IP 주소 자동 감지

#### 6.3.4 테스트 (멀티 PC)
- [ ] 서버와 클라이언트 다른 PC에서 실행
- [ ] 웹에서 프리셋 실행 → 클라이언트에서 언리얼엔진 실행
- [ ] 여러 클라이언트 동시 연결
- [ ] 네트워크 끊김 시 재연결

---

## 📦 7. Phase 4: 배포 + 문서화 (MVP)

### 7.1 배포 구조 (단순화)

```
SwitchboardPlus-v2-MVP/
├── Server/
│   ├── SBPlusServer.exe      # 서버 실행 파일
│   ├── public/               # 웹 UI
│   ├── database.sqlite       # 빈 데이터베이스
│   └── README.txt            # 서버 설치 가이드
├── Client/
│   ├── SBPlusClient.exe      # 클라이언트 실행 파일
│   ├── setup.exe             # 설정 도구
│   └── README.txt            # 클라이언트 설치 가이드
└── QuickStart.pdf            # 빠른 시작 가이드
```

### 7.2 빌드 스크립트 (단순)

```bash
# build.sh - 통합 빌드 스크립트
#!/bin/bash

echo "🔨 Switchboard Plus MVP 빌드 시작..."

# React UI 빌드
echo "📦 웹 UI 빌드..."
cd web-ui
npm run build
cd ..

# UI를 서버로 복사
cp -r web-ui/dist/* server/public/

# 서버 실행 파일 생성 (pkg 사용)
echo "🖥️ 서버 실행 파일 생성..."
npx pkg server/app.js --target node18-win-x64 --output dist/SBPlusServer.exe

# Python 클라이언트 빌드
echo "🐍 클라이언트 실행 파일 생성..."
cd client
pyinstaller --onefile main.py --name SBPlusClient
pyinstaller --onefile setup.py --name setup
cd ..

# 배포 폴더 구성
echo "📁 배포 패키지 구성..."
mkdir -p release/Server
mkdir -p release/Client

cp dist/SBPlusServer.exe release/Server/
cp -r server/public release/Server/
cp server/database-template.sqlite release/Server/database.sqlite

cp client/dist/SBPlusClient.exe release/Client/
cp client/dist/setup.exe release/Client/

echo "✅ 빌드 완료! release 폴더 확인하세요."
```

### 7.3 사용자 가이드 (필수만)

```markdown
# Switchboard Plus v2 MVP - 빠른 시작

## 🚀 10분 만에 시작하기

### 1. 서버 설치 (1대만)
1. `SBPlusServer.exe` 실행
2. 웹 브라우저에서 `http://서버IP:8000` 접속
3. 완료!

### 2. 클라이언트 설치 (Display PC마다)
1. `setup.exe` 실행하여 서버 IP 입력
2. `SBPlusClient.exe` 실행
3. 웹에서 클라이언트 확인
4. 완료!

### 3. 첫 번째 사용
1. 웹에서 "새 그룹" 생성
2. 클라이언트들을 그룹에 추가
3. "새 프리셋" 생성하고 언리얼엔진 명령 입력
4. 프리셋 실행 → 모든 PC에서 언리얼엔진 실행!

## 🆘 문제 해결
- 클라이언트 연결 안됨: 방화벽 포트 8000 확인
- 언리얼엔진 실행 안됨: 프리셋 명령어 경로 확인
- 기타: switchboardplus@email.com
```

### 7.4 Phase 4 체크리스트 (MVP)

#### 7.4.1 빌드 및 패키징
- [ ] React UI 빌드 스크립트
- [ ] 서버 실행 파일 생성 (pkg)
- [ ] Python 실행 파일 생성 (PyInstaller)
- [ ] 배포 폴더 구성

#### 7.4.2 문서화 (필수만)
- [ ] 빠른 시작 가이드 (1페이지)
- [ ] 서버 설치 방법
- [ ] 클라이언트 설치 방법
- [ ] 기본 문제 해결

#### 7.4.3 사용자 테스트
- [ ] 다른 사람이 설치 테스트
- [ ] 기본 기능 동작 확인
- [ ] 문제점 수집 및 수정
- [ ] 설치 가이드 개선

#### 7.4.4 최종 검증
- [ ] 10대 클라이언트 동시 연결 테스트
- [ ] 2시간 연속 운영 테스트
- [ ] 기본 오류 상황 테스트
- [ ] 사용자 피드백 반영

---

## 🎯 8. 성공 기준 (MVP)

### 8.1 핵심 기능 요구사항
- [ ] **웹에서 프리셋 클릭 → 모든 Display PC에서 언리얼엔진 실행**
- [ ] **5분 내 서버 설치 및 웹 접속 가능**
- [ ] **5분 내 클라이언트 설치 및 서버 연결 가능**
- [ ] **기본적인 nDisplay 운영 가능**

### 8.2 성능 요구사항 (기본)
- [ ] 5대 이상 클라이언트 동시 관리
- [ ] 웹 UI 응답 시간 5초 이내
- [ ] 2시간 이상 연속 운영 가능
- [ ] 기본적인 오류 상황 복구

### 8.3 사용성 요구사항 (기본)
- [ ] **기술 지식 없는 사용자도 설치 가능**
- [ ] **직관적인 웹 UI 사용 가능**
- [ ] **기본적인 문제 해결 가능**

---

## 🔮 9. v2.1 계획 (MVP 완성 후)

### 9.1 추가할 고급 기능들
- **보안 강화**: API 키, Rate Limiting
- **성능 최적화**: 캐싱, 연결 풀링
- **고급 UI**: 다크 테마, 반응형 디자인
- **모니터링**: 상세 메트릭, 성능 추적
- **전원 관리**: Wake-on-LAN, 원격 재부팅
- **일괄 제어**: 체크박스 다중 선택

### 9.2 v2.1 개발 전략
1. **MVP 안정성 확보** (1-2주)
2. **사용자 피드백 수집** (1주)
3. **우선순위 고급 기능 추가** (4-6주)

---

## 🔧 10. Cursor AI 협업 가이드 (MVP)

### 10.1 Phase별 작업 방식

#### Phase 1 시작
```
"Phase 1 MVP 서버를 구현해주세요.
- app.js 한 파일에 모든 기능
- Express + SQLite + Socket.io
- 클라이언트/프리셋/그룹 기본 API
- 복잡한 보안/최적화 제외"
```

#### Phase 2 시작  
```
"Phase 2 MVP 웹 UI를 구현해주세요.
- React 기본 구조
- 클라이언트/프리셋/그룹 관리
- 기본 CSS 스타일링
- 고급 UI/UX 기능 제외"
```

### 10.2 개발 우선순위
1. **동작하는 기능 우선** (완벽함보다 동작)
2. **에러 처리 최소화** (console.log + alert)
3. **기본 스타일링만** (복잡한 디자인 제외)
4. **핵심 기능 집중** (부가 기능 제외)

---

## 🎉 11. 마무리

이 **MVP 중심 개발계획서**는 **8-10주 안에 실제 동작하는 시스템**을 만들기 위한 현실적인 로드맵입니다.

### 🎯 **MVP 전략의 핵심**
1. **핵심 기능만 구현**: nDisplay 원격 제어에 필요한 최소 기능
2. **단순한 구조**: 복잡한 아키텍처 대신 동작하는 코드
3. **빠른 배포**: 완벽함보다 사용 가능한 시스템 우선
4. **점진적 개선**: v2.1에서 고급 기능 추가

### 🚀 **예상 결과**
- **Week 8**: 실제 nDisplay 환경에서 동작하는 시스템
- **Week 10**: 다른 사람이 설치해서 사용할 수 있는 배포판
- **이후**: 사용자 피드백 기반으로 v2.1 고급 기능 추가

### 💪 **성공 포인트**
- 완벽한 기능보다 **"동작하는 것"** 우선
- 복잡한 설계보다 **"간단하고 명확한 코드"** 우선  
- 모든 기능보다 **"핵심 가치 제공"** 우선

**Ready for MVP Development!** 🚀

이제 Phase 1부터 바로 개발을 시작할 수 있습니다! 