# Switchboard Plus v2.6 - ë™ê¸°í™” ì‹œìŠ¤í…œ

## ğŸ“‹ 1. ê°œìš”

**ë²„ì „**: v2.6  
**ëª©ì **: í´ë” ëª¨ë‹ˆí„°ë§, ìë™ ë™ê¸°í™”, ì¶©ëŒ í•´ê²° ë“± ê³ ê¸‰ ë™ê¸°í™” ê¸°ëŠ¥ êµ¬í˜„  
**ì „ì œ ì¡°ê±´**: v2.5 ì™„ì„± (ê³ ê¸‰ ì „ì†¡ ê¸°ëŠ¥)  
**ê°œë°œ ê¸°ê°„**: 1ì£¼  

> ğŸ¯ **í•µì‹¬ ëª©í‘œ**: ìë™í™”ëœ íŒŒì¼ ë™ê¸°í™” + ìŠ¤ë§ˆíŠ¸ ì¶©ëŒ í•´ê²° + v2.7 ê³ ê¸‰ ê´€ë¦¬ ê¸°ëŠ¥ ê¸°ë°˜ ë§ˆë ¨

---

## ğŸ¯ 2. í•µì‹¬ ê¸°ëŠ¥

### 2.1 ì‹¤ì‹œê°„ ë™ê¸°í™” ì‹œìŠ¤í…œ
```
ğŸ”„ ì‹¤ì‹œê°„ ë™ê¸°í™”
â”œâ”€â”€ íŠ¹ì • í´ë” ëª¨ë‹ˆí„°ë§
â”œâ”€â”€ íŒŒì¼ ë³€ê²½ ê°ì§€
â”œâ”€â”€ ìë™ ë™ê¸°í™” ì‹¤í–‰
â””â”€â”€ ì¶©ëŒ í•´ê²° ì „ëµ

ğŸ“‹ ë™ê¸°í™” í”„ë¡œí•„
â”œâ”€â”€ ë¯¸ë””ì–´ í´ë” ë™ê¸°í™”
â”œâ”€â”€ ì„¤ì • íŒŒì¼ ë™ê¸°í™”
â”œâ”€â”€ ì–¸ë¦¬ì–¼ í”„ë¡œì íŠ¸ ë™ê¸°í™”
â””â”€â”€ ì‚¬ìš©ì ì •ì˜ í”„ë¡œí•„
```

### 2.2 ì¶©ëŒ í•´ê²° ì‹œìŠ¤í…œ
```
âš”ï¸ ì¶©ëŒ ê°ì§€
â”œâ”€â”€ íŒŒì¼ ìˆ˜ì • ì‹œê°„ ë¹„êµ
â”œâ”€â”€ íŒŒì¼ í¬ê¸° ë³€ê²½ ê°ì§€
â”œâ”€â”€ íŒŒì¼ í•´ì‹œ ê¸°ë°˜ ë³€ê²½ ê°ì§€
â””â”€â”€ ë™ì‹œ ìˆ˜ì • ì¶©ëŒ ê°ì§€

ğŸ› ï¸ ì¶©ëŒ í•´ê²°
â”œâ”€â”€ ìë™ í•´ê²° (ìµœì‹  ìš°ì„ )
â”œâ”€â”€ ìˆ˜ë™ í•´ê²° (ì‚¬ìš©ì ì„ íƒ)
â”œâ”€â”€ ë°±ì—… ìƒì„± í›„ í•´ê²°
â””â”€â”€ ì¶©ëŒ ì´ë ¥ ê´€ë¦¬
```

### 2.3 ìŠ¤ì¼€ì¤„ë§ ì‹œìŠ¤í…œ
```
â° ìŠ¤ì¼€ì¤„ ê´€ë¦¬
â”œâ”€â”€ Cron í‘œí˜„ì‹ ê¸°ë°˜ ìŠ¤ì¼€ì¤„
â”œâ”€â”€ ì£¼ê¸°ì  ë™ê¸°í™” ì‹¤í–‰
â”œâ”€â”€ ì¡°ê±´ë¶€ ë™ê¸°í™” (ë„¤íŠ¸ì›Œí¬ ìƒíƒœ)
â””â”€â”€ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì‹¤í–‰

ğŸ“Š ë™ê¸°í™” ì´ë ¥
â”œâ”€â”€ ë™ê¸°í™” ì‹¤í–‰ ë¡œê·¸
â”œâ”€â”€ ì„±ê³µ/ì‹¤íŒ¨ í†µê³„
â”œâ”€â”€ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
â””â”€â”€ ë¬¸ì œ ì§„ë‹¨ ë„êµ¬
```

---

## ğŸ—ï¸ 3. ê¸°ìˆ  ì•„í‚¤í…ì²˜

### 3.1 í´ë” ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

```python
# client/sync_manager.py
import os
import asyncio
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class SyncManager:
    def __init__(self, file_manager):
        self.file_manager = file_manager
        self.observers = {}
        self.sync_profiles = {}
        
    def start_folder_watch(self, folder_path, profile_config):
        """í´ë” ë³€ê²½ ê°ì§€ ì‹œì‘"""
        event_handler = SyncEventHandler(self.file_manager, profile_config)
        observer = Observer()
        observer.schedule(event_handler, folder_path, recursive=True)
        observer.start()
        
        self.observers[folder_path] = observer
        
    def stop_folder_watch(self, folder_path):
        """í´ë” ë³€ê²½ ê°ì§€ ì¤‘ë‹¨"""
        if folder_path in self.observers:
            self.observers[folder_path].stop()
            del self.observers[folder_path]

class SyncEventHandler(FileSystemEventHandler):
    def __init__(self, file_manager, profile_config):
        self.file_manager = file_manager
        self.profile_config = profile_config
        self.debounce_timer = None
        
    def on_modified(self, event):
        if not event.is_directory:
            # ë””ë°”ìš´ì‹±ìœ¼ë¡œ ì¤‘ë³µ ì´ë²¤íŠ¸ ë°©ì§€
            if self.debounce_timer:
                self.debounce_timer.cancel()
            
            self.debounce_timer = asyncio.create_task(
                self.debounced_sync(event.src_path)
            )
    
    async def debounced_sync(self, file_path):
        await asyncio.sleep(2)  # 2ì´ˆ ëŒ€ê¸°
        await self.file_manager.sync_file(file_path, self.profile_config)
```

### 3.2 ë™ê¸°í™” í”„ë¡œí•„ ê´€ë¦¬

```javascript
// ë™ê¸°í™” í”„ë¡œí•„ ê´€ë¦¬ì
class SyncProfileManager {
  constructor() {
    this.profiles = new Map();
    this.scheduler = new SyncScheduler();
  }
  
  async createProfile(profileData) {
    const profile = {
      id: this.generateId(),
      name: profileData.name,
      sourcePath: profileData.sourcePath,
      targetPath: profileData.targetPath,
      syncMode: profileData.syncMode, // 'mirror', 'backup', 'bidirectional'
      autoSync: profileData.autoSync,
      fileFilters: profileData.fileFilters || [],
      excludePatterns: profileData.excludePatterns || [],
      clientGroups: profileData.clientGroups || [],
      scheduleCron: profileData.scheduleCron,
      conflictResolution: profileData.conflictResolution || 'latest',
      isActive: true,
      createdAt: new Date()
    };
    
    await this.saveProfile(profile);
    this.profiles.set(profile.id, profile);
    
    if (profile.autoSync) {
      this.scheduler.addProfile(profile);
    }
    
    return profile;
  }
  
  async executeSync(profileId, options = {}) {
    const profile = this.profiles.get(profileId);
    if (!profile) throw new Error('Profile not found');
    
    const syncJob = {
      id: this.generateId(),
      profileId: profileId,
      startTime: new Date(),
      status: 'running',
      options: options
    };
    
    try {
      const result = await this.performSync(profile, options);
      syncJob.status = 'completed';
      syncJob.result = result;
    } catch (error) {
      syncJob.status = 'failed';
      syncJob.error = error.message;
    }
    
    syncJob.endTime = new Date();
    await this.saveSyncHistory(syncJob);
    
    return syncJob;
  }
}
```

### 3.3 ì¶©ëŒ í•´ê²° ì‹œìŠ¤í…œ

```javascript
// ì¶©ëŒ í•´ê²° ê´€ë¦¬ì
class ConflictResolver {
  constructor() {
    this.resolutionStrategies = {
      'latest': this.resolveByLatest,
      'manual': this.resolveManually,
      'backup': this.resolveWithBackup,
      'skip': this.resolveBySkip
    };
  }
  
  async detectConflicts(sourceFile, targetFile) {
    const conflicts = [];
    
    // íŒŒì¼ ìˆ˜ì • ì‹œê°„ ë¹„êµ
    if (sourceFile.modifiedAt !== targetFile.modifiedAt) {
      conflicts.push({
        type: 'modification_time',
        source: sourceFile.modifiedAt,
        target: targetFile.modifiedAt
      });
    }
    
    // íŒŒì¼ í¬ê¸° ë¹„êµ
    if (sourceFile.size !== targetFile.size) {
      conflicts.push({
        type: 'file_size',
        source: sourceFile.size,
        target: targetFile.size
      });
    }
    
    // íŒŒì¼ í•´ì‹œ ë¹„êµ
    if (sourceFile.hash !== targetFile.hash) {
      conflicts.push({
        type: 'content_hash',
        source: sourceFile.hash,
        target: targetFile.hash
      });
    }
    
    return conflicts;
  }
  
  async resolveConflicts(conflicts, strategy, profile) {
    const resolver = this.resolutionStrategies[strategy];
    if (!resolver) {
      throw new Error(`Unknown resolution strategy: ${strategy}`);
    }
    
    return await resolver.call(this, conflicts, profile);
  }
  
  async resolveByLatest(conflicts, profile) {
    // ê°€ì¥ ìµœê·¼ì— ìˆ˜ì •ëœ íŒŒì¼ ìš°ì„ 
    const latestFile = conflicts.reduce((latest, conflict) => {
      return conflict.source.modifiedAt > latest.modifiedAt ? conflict.source : latest;
    });
    
    return {
      action: 'use_latest',
      selectedFile: latestFile,
      reason: 'Latest modification time'
    };
  }
  
  async resolveWithBackup(conflicts, profile) {
    // ë°±ì—… ìƒì„± í›„ í•´ê²°
    const backupPath = await this.createBackup(conflicts[0].target);
    
    return {
      action: 'backup_and_resolve',
      backupPath: backupPath,
      selectedFile: conflicts[0].source,
      reason: 'Backup created before resolution'
    };
  }
}
```

### 3.4 ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„

```sql
-- ë™ê¸°í™” í”„ë¡œí•„
CREATE TABLE sync_profiles (
    id INTEGER PRIMARY KEY,
    name VARCHAR(100),
    description TEXT,
    source_path VARCHAR(500),    -- ì†ŒìŠ¤ í´ë” ê²½ë¡œ
    target_path VARCHAR(500),    -- ëŒ€ìƒ í´ë” ê²½ë¡œ  
    sync_mode VARCHAR(20),       -- 'mirror', 'backup', 'bidirectional'
    auto_sync BOOLEAN DEFAULT false,
    file_filters JSON,           -- íŒŒì¼ í•„í„° ì¡°ê±´
    exclude_patterns JSON,       -- ì œì™¸í•  íŒ¨í„´ë“¤
    client_groups JSON,          -- ì ìš©í•  í´ë¼ì´ì–¸íŠ¸ ê·¸ë£¹
    schedule_cron VARCHAR(50),   -- ìŠ¤ì¼€ì¤„ (cron í‘œí˜„ì‹)
    conflict_resolution VARCHAR(20), -- 'latest', 'manual', 'backup', 'skip'
    is_active BOOLEAN DEFAULT true,
    created_at DATETIME
);

-- ë™ê¸°í™” ì´ë ¥
CREATE TABLE sync_history (
    id INTEGER PRIMARY KEY,
    profile_id INTEGER,
    files_added INTEGER,
    files_updated INTEGER,
    files_deleted INTEGER,
    files_conflicted INTEGER,
    total_size BIGINT,
    duration_seconds INTEGER,
    status VARCHAR(20),
    error_message TEXT,
    started_at DATETIME,
    completed_at DATETIME,
    FOREIGN KEY (profile_id) REFERENCES sync_profiles(id)
);

-- ì¶©ëŒ í•´ê²° ì´ë ¥
CREATE TABLE conflict_resolutions (
    id INTEGER PRIMARY KEY,
    sync_history_id INTEGER,
    file_path VARCHAR(500),
    conflict_type VARCHAR(50),
    resolution_strategy VARCHAR(20),
    resolution_action VARCHAR(50),
    backup_path VARCHAR(500),
    resolved_at DATETIME,
    FOREIGN KEY (sync_history_id) REFERENCES sync_history(id)
);
```

---

## ğŸ¨ 4. UI/UX ì„¤ê³„

### 4.1 ë™ê¸°í™” í”„ë¡œí•„ ê´€ë¦¬

```jsx
// SyncProfileModal.jsx
function SyncProfileModal({ open, profile, onSave, onClose }) {
  const [formData, setFormData] = useState(profile || {
    name: '',
    sourcePath: '',
    targetPath: '',
    syncMode: 'mirror',
    autoSync: false,
    fileFilters: [],
    excludePatterns: [],
    clientGroups: [],
    scheduleCron: '',
    conflictResolution: 'latest'
  });
  
  return (
    <Dialog open={open} onClose={onClose} maxWidth="md" fullWidth>
      <DialogTitle>
        {profile ? 'ë™ê¸°í™” í”„ë¡œí•„ í¸ì§‘' : 'ìƒˆ ë™ê¸°í™” í”„ë¡œí•„'}
      </DialogTitle>
      
      <DialogContent>
        <Grid container spacing={2}>
          
          {/* ê¸°ë³¸ ì •ë³´ */}
          <Grid item xs={12} md={6}>
            <TextField
              fullWidth
              label="í”„ë¡œí•„ ì´ë¦„"
              value={formData.name}
              onChange={(e) => setFormData({...formData, name: e.target.value})}
            />
          </Grid>
          
          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel>ë™ê¸°í™” ëª¨ë“œ</InputLabel>
              <Select
                value={formData.syncMode}
                onChange={(e) => setFormData({...formData, syncMode: e.target.value})}
              >
                <MenuItem value="mirror">ë¯¸ëŸ¬ë§ (ë®ì–´ì“°ê¸°)</MenuItem>
                <MenuItem value="backup">ë°±ì—… (ì¶”ê°€ë§Œ)</MenuItem>
                <MenuItem value="bidirectional">ì–‘ë°©í–¥ ë™ê¸°í™”</MenuItem>
              </Select>
            </FormControl>
          </Grid>
          
          {/* ê²½ë¡œ ì„¤ì • */}
          <Grid item xs={12} md={6}>
            <TextField
              fullWidth
              label="ì†ŒìŠ¤ ê²½ë¡œ"
              value={formData.sourcePath}
              onChange={(e) => setFormData({...formData, sourcePath: e.target.value})}
              placeholder="C:/Source/Media"
            />
          </Grid>
          
          <Grid item xs={12} md={6}>
            <TextField
              fullWidth
              label="ëŒ€ìƒ ê²½ë¡œ"
              value={formData.targetPath}
              onChange={(e) => setFormData({...formData, targetPath: e.target.value})}
              placeholder="C:/SwitchboardMedia"
            />
          </Grid>
          
          {/* ì¶©ëŒ í•´ê²° ì„¤ì • */}
          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel>ì¶©ëŒ í•´ê²° ì „ëµ</InputLabel>
              <Select
                value={formData.conflictResolution}
                onChange={(e) => setFormData({...formData, conflictResolution: e.target.value})}
              >
                <MenuItem value="latest">ìµœì‹  íŒŒì¼ ìš°ì„ </MenuItem>
                <MenuItem value="manual">ìˆ˜ë™ í•´ê²°</MenuItem>
                <MenuItem value="backup">ë°±ì—… í›„ í•´ê²°</MenuItem>
                <MenuItem value="skip">ì¶©ëŒ ê±´ë„ˆë›°ê¸°</MenuItem>
              </Select>
            </FormControl>
          </Grid>
          
          {/* ëŒ€ìƒ í´ë¼ì´ì–¸íŠ¸ */}
          <Grid item xs={12}>
            <ClientGroupSelector
              selected={formData.clientGroups}
              onChange={(groups) => setFormData({...formData, clientGroups: groups})}
              label="ë™ê¸°í™” ëŒ€ìƒ"
            />
          </Grid>
          
          {/* íŒŒì¼ í•„í„° */}
          <Grid item xs={12} md={6}>
            <TextField
              fullWidth
              label="í¬í•¨í•  íŒŒì¼ íŒ¨í„´"
              value={formData.fileFilters.join(', ')}
              onChange={(e) => setFormData({
                ...formData, 
                fileFilters: e.target.value.split(',').map(s => s.trim()).filter(Boolean)
              })}
              placeholder="*.mp4, *.jpg, *.png"
              helperText="ì‰¼í‘œë¡œ êµ¬ë¶„í•˜ì—¬ ì…ë ¥"
            />
          </Grid>
          
          <Grid item xs={12} md={6}>
            <TextField
              fullWidth
              label="ì œì™¸í•  íŒŒì¼ íŒ¨í„´"
              value={formData.excludePatterns.join(', ')}
              onChange={(e) => setFormData({
                ...formData, 
                excludePatterns: e.target.value.split(',').map(s => s.trim()).filter(Boolean)
              })}
              placeholder="*.tmp, *.log, temp/*"
              helperText="ì‰¼í‘œë¡œ êµ¬ë¶„í•˜ì—¬ ì…ë ¥"
            />
          </Grid>
          
          {/* ìë™ ë™ê¸°í™” ì„¤ì • */}
          <Grid item xs={12}>
            <FormControlLabel
              control={
                <Switch
                  checked={formData.autoSync}
                  onChange={(e) => setFormData({...formData, autoSync: e.target.checked})}
                />
              }
              label="ìë™ ë™ê¸°í™” í™œì„±í™”"
            />
          </Grid>
          
          {formData.autoSync && (
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="ìŠ¤ì¼€ì¤„ (Cron í‘œí˜„ì‹)"
                value={formData.scheduleCron}
                onChange={(e) => setFormData({...formData, scheduleCron: e.target.value})}
                placeholder="0 */1 * * * (ë§¤ì‹œê°„)"
                helperText="Cron í‘œí˜„ì‹ìœ¼ë¡œ ìŠ¤ì¼€ì¤„ ì„¤ì •"
              />
            </Grid>
          )}
          
        </Grid>
      </DialogContent>
      
      <DialogActions>
        <Button onClick={onClose}>ì·¨ì†Œ</Button>
        <Button onClick={() => onSave(formData)} variant="contained">
          ì €ì¥
        </Button>
      </DialogActions>
    </Dialog>
  );
}
```

### 4.2 ë™ê¸°í™” ìƒíƒœ ëª¨ë‹ˆí„°ë§

```jsx
// SyncStatusPanel.jsx
function SyncStatusPanel() {
  const [activeSyncs, setActiveSyncs] = useState([]);
  const [syncHistory, setSyncHistory] = useState([]);
  
  return (
    <Paper sx={{ p: 2 }}>
      <Typography variant="h6" gutterBottom>
        ë™ê¸°í™” ìƒíƒœ
      </Typography>
      
      {/* í™œì„± ë™ê¸°í™” */}
      {activeSyncs.map(sync => (
        <ActiveSyncItem 
          key={sync.id}
          sync={sync}
        />
      ))}
      
      {/* ë™ê¸°í™” ì´ë ¥ */}
      <Accordion>
        <AccordionSummary>
          <Typography>ë™ê¸°í™” ì´ë ¥ ({syncHistory.length})</Typography>
        </AccordionSummary>
        <AccordionDetails>
          {syncHistory.map(sync => (
            <SyncHistoryItem 
              key={sync.id}
              sync={sync}
            />
          ))}
        </AccordionDetails>
      </Accordion>
    </Paper>
  );
}

// ActiveSyncItem.jsx
function ActiveSyncItem({ sync }) {
  return (
    <Box sx={{ mb: 2, p: 2, border: '1px solid #eee', borderRadius: 1 }}>
      <Box display="flex" justifyContent="space-between" alignItems="center">
        <Box>
          <Typography variant="subtitle2">{sync.profileName}</Typography>
          <Typography variant="caption" color="text.secondary">
            {sync.sourcePath} â†’ {sync.targetPath}
          </Typography>
        </Box>
        
        <Box display="flex" alignItems="center" gap={1}>
          <CircularProgress 
            variant="determinate" 
            value={sync.progress} 
            size={24}
          />
          <Typography variant="caption">
            {sync.progress.toFixed(1)}%
          </Typography>
        </Box>
      </Box>
      
      {/* ë™ê¸°í™” í†µê³„ */}
      <Box mt={1}>
        <Grid container spacing={1}>
          <Grid item xs={3}>
            <Typography variant="caption" color="success.main">
              ì¶”ê°€: {sync.filesAdded}
            </Typography>
          </Grid>
          <Grid item xs={3}>
            <Typography variant="caption" color="info.main">
              ì—…ë°ì´íŠ¸: {sync.filesUpdated}
            </Typography>
          </Grid>
          <Grid item xs={3}>
            <Typography variant="caption" color="warning.main">
              ì‚­ì œ: {sync.filesDeleted}
            </Typography>
          </Grid>
          <Grid item xs={3}>
            <Typography variant="caption" color="error.main">
              ì¶©ëŒ: {sync.filesConflicted}
            </Typography>
          </Grid>
        </Grid>
      </Box>
    </Box>
  );
}
```

---

## ğŸ”§ 5. API ì„¤ê³„

### 5.1 ë™ê¸°í™” API

```javascript
// ë™ê¸°í™” í”„ë¡œí•„ ìƒì„±
POST /api/sync/profiles
Body: {
  name: "Media Sync",
  sourcePath: "/source/media",
  targetPath: "/target/media", 
  syncMode: "mirror",
  autoSync: true,
  fileFilters: ["*.mp4", "*.jpg"],
  excludePatterns: ["*.tmp"],
  clientGroups: ["group1"],
  scheduleCron: "0 */1 * * *",
  conflictResolution: "latest"
}

// ë™ê¸°í™” ì‹¤í–‰
POST /api/sync/profiles/{profileId}/execute
Body: {
  dryRun: false,  // trueë©´ ì‹œë®¬ë ˆì´ì…˜ë§Œ
  force: false    // ê°•ì œ ë™ê¸°í™”
}

// ë™ê¸°í™” ìƒíƒœ ì¡°íšŒ
GET /api/sync/profiles/{profileId}/status

// ë™ê¸°í™” ì´ë ¥ ì¡°íšŒ
GET /api/sync/profiles/{profileId}/history?page=1&limit=10

// ì¶©ëŒ í•´ê²°
POST /api/sync/conflicts/{conflictId}/resolve
Body: {
  resolution: "use_source", // or "use_target", "use_backup"
  backupPath: "/backup/path" // optional
}
```

---

## ğŸ“… 6. ê°œë°œ ì¼ì •

### Day 1-2: í´ë” ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
- [ ] íŒŒì¼ ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ ê°ì§€ êµ¬í˜„
- [ ] ë””ë°”ìš´ì‹± ë° ì¤‘ë³µ ì´ë²¤íŠ¸ ì²˜ë¦¬
- [ ] í´ë¼ì´ì–¸íŠ¸ ì¸¡ ëª¨ë‹ˆí„°ë§ ëª¨ë“ˆ

### Day 3-4: ë™ê¸°í™” í”„ë¡œí•„ ë° ì¶©ëŒ í•´ê²°
- [ ] ë™ê¸°í™” í”„ë¡œí•„ ê´€ë¦¬ ì‹œìŠ¤í…œ
- [ ] ì¶©ëŒ ê°ì§€ ë° í•´ê²° ë¡œì§
- [ ] ìŠ¤ì¼€ì¤„ë§ ì‹œìŠ¤í…œ

### Day 5: UI ë° í†µí•©
- [ ] ë™ê¸°í™” í”„ë¡œí•„ ê´€ë¦¬ UI
- [ ] ì‹¤ì‹œê°„ ë™ê¸°í™” ìƒíƒœ ëª¨ë‹ˆí„°ë§
- [ ] ë™ê¸°í™” ì´ë ¥ ë° í†µê³„

---

## ğŸ¯ 7. ì„±ê³µ ê¸°ì¤€

### 7.1 ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­
- [ ] í´ë” ë³€ê²½ ê°ì§€ 5ì´ˆ ì´ë‚´ ë°˜ì‘
- [ ] ë™ê¸°í™” í”„ë¡œí•„ 10ê°œê¹Œì§€ ë™ì‹œ ê´€ë¦¬
- [ ] ì¶©ëŒ í•´ê²° 95% ìë™ ì²˜ë¦¬
- [ ] ìŠ¤ì¼€ì¤„ ë™ê¸°í™” ì •í™•ë„ 99%

### 7.2 ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­  
- [ ] ë™ê¸°í™” ì‹¤í–‰ ì‹œê°„ 30ì´ˆ ì´ë‚´
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ 500MB ì´í•˜
- [ ] UI ì‘ë‹µì„± 2ì´ˆ ì´ë‚´

### 7.3 ì‚¬ìš©ì„± ìš”êµ¬ì‚¬í•­
- [ ] ë™ê¸°í™” í”„ë¡œí•„ 5ë¶„ ë‚´ ì„¤ì • ê°€ëŠ¥
- [ ] ì‹¤ì‹œê°„ ë™ê¸°í™” ìƒíƒœ ëª¨ë‹ˆí„°ë§
- [ ] ì¶©ëŒ í•´ê²° ì§ê´€ì  ì¸í„°í˜ì´ìŠ¤

---

## ğŸ”® 8. v2.7 ì—°ê³„ ê³ ë ¤ì‚¬í•­

### 8.1 í™•ì¥ í¬ì¸íŠ¸
- íŒŒì¼ ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ ì¤€ë¹„
- ê³ ê¸‰ ê²€ìƒ‰ ë° í•„í„°ë§ ì¤€ë¹„
- ë°±ì—… ë° ë³µêµ¬ ì‹œìŠ¤í…œ ì¤€ë¹„
- ì„±ëŠ¥ ìµœì í™” ë° ìºì‹± ì¤€ë¹„

---

*ì´ ë¬¸ì„œëŠ” v2.6 ê°œë°œ ê³¼ì •ì—ì„œ ì§€ì†ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.* 