# Switchboard Plus ÏÑúÎ≤Ñ ÏΩîÎìú ÏµúÏ†ÅÌôî - ÏôÑÏ†ÑÌïú Íµ¨ÌòÑ Í∞ÄÏù¥Îìú

## üìÅ ÏÉàÎ°úÏö¥ ÌååÏùº Íµ¨Ï°∞

```
server/
‚îú‚îÄ‚îÄ app.js
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ database.js
‚îÇ   ‚îî‚îÄ‚îÄ server.js
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îî‚îÄ‚îÄ migrations.js
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ Client.js
‚îÇ   ‚îú‚îÄ‚îÄ Group.js
‚îÇ   ‚îú‚îÄ‚îÄ Preset.js
‚îÇ   ‚îî‚îÄ‚îÄ Execution.js
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îú‚îÄ‚îÄ clientController.js
‚îÇ   ‚îú‚îÄ‚îÄ groupController.js
‚îÇ   ‚îú‚îÄ‚îÄ presetController.js
‚îÇ   ‚îî‚îÄ‚îÄ executionController.js
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ socketService.js
‚îÇ   ‚îú‚îÄ‚îÄ clientService.js
‚îÇ   ‚îî‚îÄ‚îÄ executionService.js
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ clients.js
‚îÇ   ‚îú‚îÄ‚îÄ groups.js
‚îÇ   ‚îú‚îÄ‚îÄ presets.js
‚îÇ   ‚îî‚îÄ‚îÄ executions.js
‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îú‚îÄ‚îÄ errorHandler.js
‚îÇ   ‚îî‚îÄ‚îÄ validation.js
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ logger.js
    ‚îî‚îÄ‚îÄ helpers.js
```

## üìù Í∞Å ÌååÏùºÏùò ÏôÑÏ†ÑÌïú ÏΩîÎìú

### 1. config/server.js
```javascript
module.exports = {
  // ÏÑúÎ≤Ñ ÏÑ§Ï†ï
  server: {
    port: process.env.PORT || 8000,
    host: process.env.HOST || 'localhost'
  },
  
  // CORS ÏÑ§Ï†ï
  cors: {
    origin: process.env.CORS_ORIGIN || '*',
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    credentials: true
  },
  
  // Socket.IO ÏÑ§Ï†ï
  socket: {
    cors: {
      origin: '*',
      methods: ['GET', 'POST']
    },
    pingInterval: 25000,
    pingTimeout: 60000,
    transports: ['websocket', 'polling']
  },
  
  // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ§Ï†ï
  database: {
    filename: process.env.DB_FILE || './ue_cms.db',
    busyTimeout: 5000,
    verbose: process.env.NODE_ENV === 'development'
  },
  
  // Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï
  monitoring: {
    healthCheckInterval: 15000,    // 15Ï¥à
    offlineTimeout: 60000,         // 60Ï¥à
    connectionCheckInterval: 15000, // 15Ï¥à
    processCheckInterval: 10000    // 10Ï¥à
  },
  
  // Î°úÍπÖ ÏÑ§Ï†ï
  logging: {
    level: process.env.LOG_LEVEL || 'info',
    filename: 'logs/app.log',
    errorFilename: 'logs/error.log',
    maxSize: '10m',
    maxFiles: '7d'
  }
};
```

### 2. config/database.js
```javascript
const sqlite3 = require('sqlite3').verbose();
const { promisify } = require('util');
const path = require('path');
const config = require('./server');

class Database {
  constructor() {
    this.db = null;
    this.isInitialized = false;
  }

  async initialize() {
    if (this.isInitialized) return;

    const dbPath = path.resolve(config.database.filename);
    
    return new Promise((resolve, reject) => {
      this.db = new sqlite3.Database(dbPath, (err) => {
        if (err) {
          console.error('Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïã§Ìå®:', err);
          reject(err);
        } else {
          console.log('‚úÖ SQLite Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏÑ±Í≥µ');
          this.setupPromisifiedMethods();
          this.optimizeDatabase();
          this.isInitialized = true;
          resolve();
        }
      });
    });
  }

  setupPromisifiedMethods() {
    this.run = promisify(this.db.run.bind(this.db));
    this.get = promisify(this.db.get.bind(this.db));
    this.all = promisify(this.db.all.bind(this.db));
    this.exec = promisify(this.db.exec.bind(this.db));
  }

  async optimizeDatabase() {
    try {
      await this.run('PRAGMA journal_mode = WAL');
      await this.run('PRAGMA synchronous = NORMAL');
      await this.run('PRAGMA cache_size = 10000');
      await this.run('PRAGMA temp_store = MEMORY');
      await this.run('PRAGMA mmap_size = 30000000000');
      console.log('‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏµúÏ†ÅÌôî ÏôÑÎ£å');
    } catch (error) {
      console.error('Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏµúÏ†ÅÌôî Ïã§Ìå®:', error);
    }
  }

  async transaction(callback) {
    await this.run('BEGIN TRANSACTION');
    try {
      const result = await callback();
      await this.run('COMMIT');
      return result;
    } catch (error) {
      await this.run('ROLLBACK');
      throw error;
    }
  }

  async close() {
    return new Promise((resolve, reject) => {
      if (this.db) {
        this.db.close((err) => {
          if (err) {
            reject(err);
          } else {
            console.log('‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ï¢ÖÎ£å');
            resolve();
          }
        });
      } else {
        resolve();
      }
    });
  }

  // Ìó¨Ìçº Î©îÏÑúÎìúÎì§
  async exists(table, conditions) {
    const keys = Object.keys(conditions);
    const where = keys.map(k => `${k} = ?`).join(' AND ');
    const values = keys.map(k => conditions[k]);
    
    const result = await this.get(
      `SELECT COUNT(*) as count FROM ${table} WHERE ${where}`,
      values
    );
    
    return result.count > 0;
  }

  async insert(table, data) {
    const keys = Object.keys(data);
    const values = keys.map(k => data[k]);
    const placeholders = keys.map(() => '?').join(', ');
    
    const result = await this.run(
      `INSERT INTO ${table} (${keys.join(', ')}) VALUES (${placeholders})`,
      values
    );
    
    return result.lastID;
  }

  async update(table, data, conditions) {
    const dataKeys = Object.keys(data);
    const setClause = dataKeys.map(k => `${k} = ?`).join(', ');
    const dataValues = dataKeys.map(k => data[k]);
    
    const condKeys = Object.keys(conditions);
    const whereClause = condKeys.map(k => `${k} = ?`).join(' AND ');
    const condValues = condKeys.map(k => conditions[k]);
    
    const result = await this.run(
      `UPDATE ${table} SET ${setClause} WHERE ${whereClause}`,
      [...dataValues, ...condValues]
    );
    
    return result.changes;
  }

  async delete(table, conditions) {
    const keys = Object.keys(conditions);
    const where = keys.map(k => `${k} = ?`).join(' AND ');
    const values = keys.map(k => conditions[k]);
    
    const result = await this.run(
      `DELETE FROM ${table} WHERE ${where}`,
      values
    );
    
    return result.changes;
  }
}

module.exports = new Database();
```

### 3. db/migrations.js
```javascript
const db = require('../config/database');

const migrations = [
  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÌÖåÏù¥Î∏î
  `CREATE TABLE IF NOT EXISTS clients (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    ip_address TEXT NOT NULL,
    port INTEGER DEFAULT 8081,
    status TEXT DEFAULT 'offline',
    last_seen DATETIME,
    current_preset_id INTEGER,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (current_preset_id) REFERENCES presets (id)
  )`,
  
  // Í∑∏Î£π ÌÖåÏù¥Î∏î
  `CREATE TABLE IF NOT EXISTS groups (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`,
  
  // Í∑∏Î£π-ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Í¥ÄÍ≥Ñ
  `CREATE TABLE IF NOT EXISTS group_clients (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    group_id INTEGER NOT NULL,
    client_id INTEGER NOT NULL,
    FOREIGN KEY (group_id) REFERENCES groups (id) ON DELETE CASCADE,
    FOREIGN KEY (client_id) REFERENCES clients (id) ON DELETE CASCADE,
    UNIQUE(group_id, client_id)
  )`,
  
  // ÌîÑÎ¶¨ÏÖã ÌÖåÏù¥Î∏î
  `CREATE TABLE IF NOT EXISTS presets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    target_group_id INTEGER,
    client_commands TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (target_group_id) REFERENCES groups (id) ON DELETE SET NULL
  )`,
  
  // Ïã§Ìñâ ÌûàÏä§ÌÜ†Î¶¨
  `CREATE TABLE IF NOT EXISTS execution_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    preset_id INTEGER,
    client_id INTEGER,
    status TEXT,
    result TEXT,
    executed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (preset_id) REFERENCES presets (id),
    FOREIGN KEY (client_id) REFERENCES clients (id)
  )`,
  
  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†ÑÏõê Ï†ïÎ≥¥
  `CREATE TABLE IF NOT EXISTS client_power_info (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    client_id INTEGER UNIQUE,
    mac_address VARCHAR(17),
    is_manual BOOLEAN DEFAULT false,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (client_id) REFERENCES clients (id) ON DELETE CASCADE
  )`,
  
  // IP-MAC ÌûàÏä§ÌÜ†Î¶¨
  `CREATE TABLE IF NOT EXISTS ip_mac_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ip_address TEXT NOT NULL,
    mac_address VARCHAR(17) NOT NULL,
    is_manual BOOLEAN DEFAULT false,
    last_used DATETIME DEFAULT CURRENT_TIMESTAMP,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`,
  
  // IP-Ïù¥Î¶Ñ ÌûàÏä§ÌÜ†Î¶¨
  `CREATE TABLE IF NOT EXISTS ip_name_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ip_address TEXT NOT NULL,
    user_modified_name TEXT NOT NULL,
    original_name TEXT NOT NULL,
    last_used DATETIME DEFAULT CURRENT_TIMESTAMP,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`,
  
  // Ïù∏Îç±Ïä§Îì§
  `CREATE INDEX IF NOT EXISTS idx_clients_ip ON clients(ip_address)`,
  `CREATE INDEX IF NOT EXISTS idx_clients_status ON clients(status)`,
  `CREATE INDEX IF NOT EXISTS idx_ip_mac_history_ip ON ip_mac_history(ip_address)`,
  `CREATE INDEX IF NOT EXISTS idx_ip_mac_history_mac ON ip_mac_history(mac_address)`,
  `CREATE INDEX IF NOT EXISTS idx_ip_name_history_ip ON ip_name_history(ip_address)`,
  `CREATE INDEX IF NOT EXISTS idx_execution_history_time ON execution_history(executed_at)`
];

async function runMigrations() {
  console.log('üîÑ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏãúÏûë...');
  
  try {
    for (const migration of migrations) {
      await db.run(migration);
    }
    
    console.log('‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å');
    
    // Î¨¥Í≤∞ÏÑ± Í≤ÄÏÇ¨
    await checkDatabaseIntegrity();
  } catch (error) {
    console.error('‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìå®:', error);
    throw error;
  }
}

async function checkDatabaseIntegrity() {
  console.log('üîç Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î¨¥Í≤∞ÏÑ± Í≤ÄÏÇ¨ Ï§ë...');
  
  try {
    // Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º Ï∞∏Ï°∞ÌïòÎäî Í∑∏Î£π Ïó∞Í≤∞ Ï†ïÎ¶¨
    const result1 = await db.run(`
      DELETE FROM group_clients 
      WHERE client_id NOT IN (SELECT id FROM clients)
    `);
    if (result1.changes > 0) {
      console.log(`‚úÖ ${result1.changes}Í∞úÏùò Î¨¥Ìö®Ìïú Í∑∏Î£π-ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ï†ïÎ¶¨Îê®`);
    }
    
    // Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Í∑∏Î£πÏùÑ Ï∞∏Ï°∞ÌïòÎäî ÌîÑÎ¶¨ÏÖã Ï†ïÎ¶¨
    const result2 = await db.run(`
      UPDATE presets 
      SET target_group_id = NULL 
      WHERE target_group_id NOT IN (SELECT id FROM groups)
    `);
    if (result2.changes > 0) {
      console.log(`‚úÖ ${result2.changes}Í∞úÏùò Î¨¥Ìö®Ìïú ÌîÑÎ¶¨ÏÖã Í∑∏Î£π Ï∞∏Ï°∞ Ï†ïÎ¶¨Îê®`);
    }
    
    console.log('‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î¨¥Í≤∞ÏÑ± Í≤ÄÏÇ¨ ÏôÑÎ£å');
  } catch (error) {
    console.error('‚ùå Î¨¥Í≤∞ÏÑ± Í≤ÄÏÇ¨ Ïã§Ìå®:', error);
  }
}

module.exports = { runMigrations, checkDatabaseIntegrity };
```

### 4. models/Client.js
```javascript
const db = require('../config/database');

class ClientModel {
  // Î™®Îì† ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå (MAC Ï£ºÏÜå Ìè¨Ìï®)
  static async findAll() {
    const query = `
      SELECT 
        c.*,
        cpi.mac_address,
        cpi.is_manual as mac_is_manual
      FROM clients c
      LEFT JOIN (
        SELECT client_id, mac_address, is_manual, updated_at 
        FROM client_power_info cpi1 
        WHERE updated_at = (
          SELECT MAX(updated_at) 
          FROM client_power_info cpi2 
          WHERE cpi2.client_id = cpi1.client_id
        )
      ) cpi ON c.id = cpi.client_id
      ORDER BY c.id
    `;
    
    return await db.all(query);
  }

  // IDÎ°ú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå
  static async findById(id) {
    return await db.get('SELECT * FROM clients WHERE id = ?', [id]);
  }

  // Ïù¥Î¶ÑÏúºÎ°ú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå
  static async findByName(name) {
    return await db.get('SELECT * FROM clients WHERE name = ?', [name]);
  }

  // IPÎ°ú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå
  static async findByIP(ip) {
    return await db.get('SELECT * FROM clients WHERE ip_address = ?', [ip]);
  }

  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
  static async create(data) {
    const { name, ip_address, port = 8081 } = data;
    
    return await db.transaction(async () => {
      // Í∞ôÏùÄ Ïù¥Î¶ÑÏùò Í∏∞Ï°¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÇ≠Ï†ú
      await db.run('DELETE FROM clients WHERE name = ?', [name]);
      
      // ÏÉà ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
      const result = await db.run(
        'INSERT INTO clients (name, ip_address, port, status) VALUES (?, ?, ?, ?)',
        [name, ip_address, port, 'online']
      );
      
      return await this.findById(result.lastID);
    });
  }

  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
  static async update(id, data) {
    const { name, ip_address, port } = data;
    
    // Í∏∞Ï°¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå
    const existing = await this.findById(id);
    if (!existing) {
      throw new Error('ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
    }

    // ÏóÖÎç∞Ïù¥Ìä∏
    await db.run(
      'UPDATE clients SET name = ?, ip_address = ?, port = ? WHERE id = ?',
      [name, ip_address, port, id]
    );

    // Ïù¥Î¶ÑÏù¥ Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû•
    if (name !== existing.name) {
      await db.run(
        'INSERT OR REPLACE INTO ip_name_history (ip_address, user_modified_name, original_name, last_used) VALUES (?, ?, ?, datetime("now"))',
        [ip_address, name, existing.name]
      );
    }

    return await this.findById(id);
  }

  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÇ≠Ï†ú
  static async delete(id) {
    return await db.transaction(async () => {
      const client = await this.findById(id);
      if (!client) {
        throw new Error('ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
      }

      // Í¥ÄÎ†® Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú (CASCADE ÏÑ§Ï†ïÏúºÎ°ú ÏûêÎèô Ï≤òÎ¶¨)
      const result = await db.run('DELETE FROM clients WHERE id = ?', [id]);
      
      return result.changes > 0;
    });
  }

  // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
  static async updateStatus(id, status) {
    const result = await db.run(
      'UPDATE clients SET status = ?, last_seen = datetime("now") WHERE id = ?',
      [status, id]
    );
    
    return result.changes > 0;
  }

  // ÌïòÌä∏ÎπÑÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
  static async updateHeartbeat(name, ip_address, port = 8081) {
    // Í∏∞Ï°¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÌôïÏù∏
    let client = await this.findByName(name) || await this.findByIP(ip_address);
    
    if (client) {
      // Í∏∞Ï°¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
      await db.run(
        'UPDATE clients SET ip_address = ?, port = ?, status = ?, last_seen = datetime("now") WHERE id = ?',
        [ip_address, port, 'online', client.id]
      );
      return await this.findById(client.id);
    } else {
      // ÏÉà ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏûêÎèô Îì±Î°ù
      return await this.create({ name, ip_address, port });
    }
  }

  // MAC Ï£ºÏÜå ÏóÖÎç∞Ïù¥Ìä∏
  static async updateMacAddress(id, macAddress, isManual = false) {
    // Í∏∞Ï°¥ MAC Ï£ºÏÜå Ï†ïÎ≥¥ ÌôïÏù∏
    const existing = await db.get(
      'SELECT mac_address, is_manual FROM client_power_info WHERE client_id = ?',
      [id]
    );
    
    // ÏàòÎèô ÏûÖÎ†•Îêú MAC Ï£ºÏÜåÍ∞Ä ÏûàÏúºÎ©¥ ÏûêÎèô ÏàòÏßëÏúºÎ°ú ÎçÆÏñ¥Ïì∞ÏßÄ ÏïäÏùå
    if (existing && existing.is_manual && !isManual) {
      return {
        success: false,
        message: 'ÏàòÎèô ÏûÖÎ†•Îêú MAC Ï£ºÏÜåÍ∞Ä ÏûàÏñ¥ ÏûêÎèô ÏàòÏßë MAC Ï£ºÏÜåÎ•º Î¨¥ÏãúÌï©ÎãàÎã§.',
        mac_address: existing.mac_address,
        is_manual: true
      };
    }
    
    // MAC Ï£ºÏÜå Ï†ÄÏû• ÎòêÎäî ÏóÖÎç∞Ïù¥Ìä∏
    await db.run(
      'INSERT OR REPLACE INTO client_power_info (client_id, mac_address, updated_at, is_manual) VALUES (?, ?, datetime("now"), ?)',
      [id, macAddress, isManual ? 1 : 0]
    );
    
    // IP Ï£ºÏÜå ÌûàÏä§ÌÜ†Î¶¨ÏóêÎèÑ Ï†ÄÏû•
    const client = await this.findById(id);
    if (client) {
      await db.run(
        'INSERT OR REPLACE INTO ip_mac_history (ip_address, mac_address, is_manual, last_used) VALUES (?, ?, ?, datetime("now"))',
        [client.ip_address, macAddress, isManual ? 1 : 0]
      );
    }
    
    return {
      success: true,
      message: 'MAC Ï£ºÏÜåÍ∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.',
      mac_address: macAddress,
      is_manual: isManual
    };
  }

  // Ïò®ÎùºÏù∏ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå
  static async findOnlineClients() {
    return await db.all(
      'SELECT * FROM clients WHERE status IN ("online", "running") ORDER BY name'
    );
  }

  // Ïò§ÌîÑÎùºÏù∏ Ï≤òÎ¶¨
  static async markOfflineByTimeout(timeoutMs = 60000) {
    const cutoffTime = new Date(Date.now() - timeoutMs).toISOString();
    
    const result = await db.run(
      'UPDATE clients SET status = "offline" WHERE status = "online" AND last_seen < ?',
      [cutoffTime]
    );
    
    return result.changes;
  }
}

module.exports = ClientModel;
```

### 5. models/Group.js
```javascript
const db = require('../config/database');

class GroupModel {
  // Î™®Îì† Í∑∏Î£π Ï°∞Ìöå (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†ïÎ≥¥ Ìè¨Ìï®)
  static async findAll() {
    const groups = await db.all('SELECT * FROM groups ORDER BY created_at DESC');
    
    // Í∞Å Í∑∏Î£πÏùò ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†ïÎ≥¥ Ï°∞Ìöå
    for (const group of groups) {
      group.clients = await this.getGroupClients(group.id);
    }
    
    return groups;
  }

  // IDÎ°ú Í∑∏Î£π Ï°∞Ìöå
  static async findById(id) {
    const group = await db.get('SELECT * FROM groups WHERE id = ?', [id]);
    if (group) {
      group.clients = await this.getGroupClients(id);
    }
    return group;
  }

  // Í∑∏Î£πÏùò ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå
  static async getGroupClients(groupId) {
    const query = `
      SELECT c.id, c.name, c.ip_address, c.status, c.last_seen
      FROM group_clients gc
      JOIN clients c ON gc.client_id = c.id
      WHERE gc.group_id = ?
      ORDER BY c.name
    `;
    
    return await db.all(query, [groupId]);
  }

  // Í∑∏Î£π ÏÉùÏÑ±
  static async create(data) {
    const { name, description, client_ids = [] } = data;
    
    return await db.transaction(async () => {
      // Í∑∏Î£π ÏÉùÏÑ±
      const result = await db.run(
        'INSERT INTO groups (name, description) VALUES (?, ?)',
        [name, description]
      );
      
      const groupId = result.lastID;
      
      // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞
      for (const clientId of client_ids) {
        await db.run(
          'INSERT INTO group_clients (group_id, client_id) VALUES (?, ?)',
          [groupId, clientId]
        );
      }
      
      return await this.findById(groupId);
    });
  }

  // Í∑∏Î£π ÏóÖÎç∞Ïù¥Ìä∏
  static async update(id, data) {
    const { name, description, client_ids = [] } = data;
    
    return await db.transaction(async () => {
      // Í∑∏Î£π Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
      await db.run(
        'UPDATE groups SET name = ?, description = ? WHERE id = ?',
        [name, description, id]
      );
      
      // Í∏∞Ï°¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ ÏÇ≠Ï†ú
      await db.run('DELETE FROM group_clients WHERE group_id = ?', [id]);
      
      // ÏÉà ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ï∂îÍ∞Ä
      for (const clientId of client_ids) {
        await db.run(
          'INSERT INTO group_clients (group_id, client_id) VALUES (?, ?)',
          [id, clientId]
        );
      }
      
      return await this.findById(id);
    });
  }

  // Í∑∏Î£π ÏÇ≠Ï†ú
  static async delete(id) {
    return await db.transaction(async () => {
      // Í∑∏Î£π-ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ ÏÇ≠Ï†ú
      await db.run('DELETE FROM group_clients WHERE group_id = ?', [id]);
      
      // Í∑∏Î£π ÏÇ≠Ï†ú
      const result = await db.run('DELETE FROM groups WHERE id = ?', [id]);
      
      return result.changes > 0;
    });
  }

  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä ÏÜçÌïú Í∑∏Î£πÎì§ Ï°∞Ìöå
  static async findByClientId(clientId) {
    const query = `
      SELECT g.*
      FROM groups g
      JOIN group_clients gc ON g.id = gc.group_id
      WHERE gc.client_id = ?
      ORDER BY g.name
    `;
    
    return await db.all(query, [clientId]);
  }
}

module.exports = GroupModel;
```

### 6. models/Preset.js
```javascript
const db = require('../config/database');

class PresetModel {
  // Î™®Îì† ÌîÑÎ¶¨ÏÖã Ï°∞Ìöå
  static async findAll() {
    const query = `
      SELECT p.*, g.name as group_name 
      FROM presets p
      LEFT JOIN groups g ON p.target_group_id = g.id
      ORDER BY p.created_at DESC
    `;
    
    const presets = await db.all(query);
    
    // client_commands JSON ÌååÏã±
    return presets.map(preset => ({
      ...preset,
      client_commands: preset.client_commands ? JSON.parse(preset.client_commands) : {}
    }));
  }

  // IDÎ°ú ÌîÑÎ¶¨ÏÖã Ï°∞Ìöå
  static async findById(id) {
    const query = `
      SELECT p.*, g.name as group_name 
      FROM presets p
      LEFT JOIN groups g ON p.target_group_id = g.id
      WHERE p.id = ?
    `;
    
    const preset = await db.get(query, [id]);
    
    if (preset) {
      preset.client_commands = preset.client_commands ? 
        JSON.parse(preset.client_commands) : {};
    }
    
    return preset;
  }

  // ÌîÑÎ¶¨ÏÖã ÏÉùÏÑ±
  static async create(data) {
    const { name, description, target_group_id, client_commands } = data;
    
    const clientCommandsJson = JSON.stringify(client_commands);
    
    const result = await db.run(
      'INSERT INTO presets (name, description, target_group_id, client_commands) VALUES (?, ?, ?, ?)',
      [name, description, target_group_id, clientCommandsJson]
    );
    
    return await this.findById(result.lastID);
  }

  // ÌîÑÎ¶¨ÏÖã ÏóÖÎç∞Ïù¥Ìä∏
  static async update(id, data) {
    const { name, description, target_group_id, client_commands } = data;
    
    const clientCommandsJson = JSON.stringify(client_commands);
    
    const result = await db.run(
      'UPDATE presets SET name = ?, description = ?, target_group_id = ?, client_commands = ? WHERE id = ?',
      [name, description, target_group_id, clientCommandsJson, id]
    );
    
    if (result.changes === 0) {
      throw new Error('ÌîÑÎ¶¨ÏÖãÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
    }
    
    return await this.findById(id);
  }

  // ÌîÑÎ¶¨ÏÖã ÏÇ≠Ï†ú
  static async delete(id) {
    const result = await db.run('DELETE FROM presets WHERE id = ?', [id]);
    return result.changes > 0;
  }

  // ÌîÑÎ¶¨ÏÖã ÎåÄÏÉÅ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå
  static async getTargetClients(id) {
    const preset = await this.findById(id);
    if (!preset || !preset.target_group_id) {
      return [];
    }
    
    const query = `
      SELECT c.*
      FROM clients c
      JOIN group_clients gc ON c.id = gc.client_id
      WHERE gc.group_id = ?
    `;
    
    return await db.all(query, [preset.target_group_id]);
  }

  // ÌîÑÎ¶¨ÏÖã Ïã§Ìñâ Ïù¥Î†• Ï∂îÍ∞Ä
  static async addExecutionHistory(presetId, clientId, status) {
    await db.run(
      'INSERT INTO execution_history (preset_id, client_id, status) VALUES (?, ?, ?)',
      [presetId, clientId, status]
    );
  }
}

module.exports = PresetModel;
```

### 7. models/Execution.js
```javascript
const db = require('../config/database');

class ExecutionModel {
  // Ïã§Ìñâ Ïù¥Î†• Ï°∞Ìöå
  static async findAll(limit = 50) {
    const query = `
      SELECT 
        eh.id,
        eh.status,
        eh.executed_at,
        p.name as preset_name,
        c.name as client_name
      FROM execution_history eh
      LEFT JOIN presets p ON eh.preset_id = p.id
      LEFT JOIN clients c ON eh.client_id = c.id
      ORDER BY eh.executed_at DESC
      LIMIT ?
    `;
    
    return await db.all(query, [limit]);
  }

  // ÌîÑÎ¶¨ÏÖãÎ≥Ñ Ïã§Ìñâ Ïù¥Î†•
  static async findByPresetId(presetId, limit = 100) {
    const query = `
      SELECT eh.*, c.name as client_name
      FROM execution_history eh
      JOIN clients c ON eh.client_id = c.id
      WHERE eh.preset_id = ?
      ORDER BY eh.executed_at DESC
      LIMIT ?
    `;
    
    return await db.all(query, [presetId, limit]);
  }

  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î≥Ñ Ïã§Ìñâ Ïù¥Î†•
  static async findByClientId(clientId, limit = 100) {
    const query = `
      SELECT eh.*, p.name as preset_name
      FROM execution_history eh
      JOIN presets p ON eh.preset_id = p.id
      WHERE eh.client_id = ?
      ORDER BY eh.executed_at DESC
      LIMIT ?
    `;
    
    return await db.all(query, [clientId, limit]);
  }

  // Ïã§Ìñâ Í∏∞Î°ù ÏÉùÏÑ±
  static async create(presetId, clientId, status) {
    const result = await db.run(
      'INSERT INTO execution_history (preset_id, client_id, status) VALUES (?, ?, ?)',
      [presetId, clientId, status]
    );
    
    return result.lastID;
  }

  // Ïã§Ìñâ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
  static async updateStatus(id, status, result = null) {
    await db.run(
      'UPDATE execution_history SET status = ?, result = ? WHERE id = ?',
      [status, result, id]
    );
  }

  // ÌÜµÍ≥Ñ Ï°∞Ìöå
  static async getStatistics() {
    const stats = {};
    
    // Ï†ÑÏ≤¥ Ïã§Ìñâ Ïàò
    const totalResult = await db.get(
      'SELECT COUNT(*) as total FROM execution_history'
    );
    stats.total = totalResult.total;
    
    // ÏÉÅÌÉúÎ≥Ñ Ïã§Ìñâ Ïàò
    const statusResult = await db.all(`
      SELECT status, COUNT(*) as count 
      FROM execution_history 
      GROUP BY status
    `);
    stats.byStatus = statusResult.reduce((acc, row) => {
      acc[row.status] = row.count;
      return acc;
    }, {});
    
    // ÏµúÍ∑º 24ÏãúÍ∞Ñ Ïã§Ìñâ Ïàò
    const recentResult = await db.get(`
      SELECT COUNT(*) as recent 
      FROM execution_history 
      WHERE executed_at > datetime('now', '-24 hours')
    `);
    stats.recent24Hours = recentResult.recent;
    
    return stats;
  }
}

module.exports = ExecutionModel;
```

### 8. controllers/clientController.js
```javascript
const ClientModel = require('../models/Client');
const socketService = require('../services/socketService');
const logger = require('../utils/logger');

class ClientController {
  // Î™®Îì† ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå
  static async getAll(req, res, next) {
    try {
      const clients = await ClientModel.findAll();
      res.json(clients);
    } catch (error) {
      logger.error('ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå Ïã§Ìå®:', error);
      next(error);
    }
  }

  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
  static async create(req, res, next) {
    try {
      const { name, ip_address, port } = req.body;
      
      // Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
      if (!name || !ip_address) {
        return res.status(400).json({ 
          error: 'Ïù¥Î¶ÑÍ≥º IP Ï£ºÏÜåÎäî ÌïÑÏàòÏûÖÎãàÎã§.' 
        });
      }

      const client = await ClientModel.create({ name, ip_address, port });
      
      // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
      socketService.emit('client_added', client);
      
      logger.info(`ÏÉà ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îì±Î°ù: ${name} (${ip_address})`);
      res.status(201).json(client);
    } catch (error) {
      logger.error('ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ± Ïã§Ìå®:', error);
      next(error);
    }
  }

  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
  static async update(req, res, next) {
    try {
      const { id } = req.params;
      const { name, ip_address, port } = req.body;
      
      if (!name || !ip_address) {
        return res.status(400).json({ 
          error: 'Ïù¥Î¶ÑÍ≥º IP Ï£ºÏÜåÎäî ÌïÑÏàòÏûÖÎãàÎã§.' 
        });
      }

      const client = await ClientModel.update(id, { name, ip_address, port });
      
      // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
      socketService.emit('client_updated', client);
      
      logger.info(`ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏: ${name} (ID: ${id})`);
      res.json(client);
    } catch (error) {
      if (error.message === 'ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.') {
        return res.status(404).json({ error: error.message });
      }
      logger.error('ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error);
      next(error);
    }
  }

  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÇ≠Ï†ú
  static async delete(req, res, next) {
    try {
      const { id } = req.params;
      
      const success = await ClientModel.delete(id);
      
      if (!success) {
        return res.status(404).json({ 
          error: 'ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.' 
        });
      }

      // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
      socketService.emit('client_deleted', { id: parseInt(id) });
      
      logger.info(`ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÇ≠Ï†ú: ID ${id}`);
      res.json({ message: 'ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.' });
    } catch (error) {
      logger.error('ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÇ≠Ï†ú Ïã§Ìå®:', error);
      next(error);
    }
  }

  // MAC Ï£ºÏÜå ÏóÖÎç∞Ïù¥Ìä∏
  static async updateMacAddress(req, res, next) {
    try {
      const { id } = req.params;
      const { mac_address, is_manual = false } = req.body;
      
      if (!mac_address) {
        return res.status(400).json({ 
          error: 'MAC Ï£ºÏÜåÎäî ÌïÑÏàòÏûÖÎãàÎã§.' 
        });
      }

      const result = await ClientModel.updateMacAddress(id, mac_address, is_manual);
      
      if (result.success) {
        // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
        socketService.emit('mac_address_updated', {
          clientId: parseInt(id),
          macAddress: mac_address,
          isManual: is_manual
        });
      }
      
      res.json(result);
    } catch (error) {
      logger.error('MAC Ï£ºÏÜå ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error);
      next(error);
    }
  }

  // ÌïòÌä∏ÎπÑÌä∏ Ï≤òÎ¶¨
  static async heartbeat(req, res, next) {
    try {
      const { clientName, ip_address, port = 8081 } = req.body;
      
      if (!clientName || !ip_address) {
        return res.status(400).json({ 
          error: 'ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïù¥Î¶ÑÍ≥º IP Ï£ºÏÜåÎäî ÌïÑÏàòÏûÖÎãàÎã§.' 
        });
      }

      const client = await ClientModel.updateHeartbeat(clientName, ip_address, port);
      
      // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
      socketService.emit('client_status_changed', {
        id: client.id,
        name: clientName,
        status: 'online',
        ip_address: ip_address
      });
      
      res.json({ 
        success: true, 
        message: 'ÌïòÌä∏ÎπÑÌä∏ Ï≤òÎ¶¨ ÏôÑÎ£å',
        clientId: client.id
      });
    } catch (error) {
      logger.error('ÌïòÌä∏ÎπÑÌä∏ Ï≤òÎ¶¨ Ïã§Ìå®:', error);
      next(error);
    }
  }
}

module.exports = ClientController;
```

### 9. controllers/groupController.js
```javascript
const GroupModel = require('../models/Group');
const socketService = require('../services/socketService');
const logger = require('../utils/logger');

class GroupController {
  // Î™®Îì† Í∑∏Î£π Ï°∞Ìöå
  static async getAll(req, res, next) {
    try {
      const groups = await GroupModel.findAll();
      res.json(groups);
    } catch (error) {
      logger.error('Í∑∏Î£π Ï°∞Ìöå Ïã§Ìå®:', error);
      next(error);
    }
  }

  // Í∑∏Î£π ÏÉùÏÑ±
  static async create(req, res, next) {
    try {
      const { name, description, client_ids } = req.body;
      
      if (!name) {
        return res.status(400).json({ 
          error: 'Í∑∏Î£π Ïù¥Î¶ÑÏùÄ ÌïÑÏàòÏûÖÎãàÎã§.' 
        });
      }
      
      if (!client_ids || !Array.isArray(client_ids) || client_ids.length === 0) {
        return res.status(400).json({ 
          error: 'ÏµúÏÜå Ìïú Í∞úÏùò ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º Í∑∏Î£πÏóê Ìè¨Ìï®Ìï¥Ïïº Ìï©ÎãàÎã§.' 
        });
      }

      const group = await GroupModel.create({ name, description, client_ids });
      
      // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
      socketService.emit('group_added', group);
      
      logger.info(`ÏÉà Í∑∏Î£π ÏÉùÏÑ±: ${name}`);
      res.status(201).json(group);
    } catch (error) {
      logger.error('Í∑∏Î£π ÏÉùÏÑ± Ïã§Ìå®:', error);
      next(error);
    }
  }

  // Í∑∏Î£π ÏóÖÎç∞Ïù¥Ìä∏
  static async update(req, res, next) {
    try {
      const { id } = req.params;
      const { name, description, client_ids } = req.body;
      
      if (!name) {
        return res.status(400).json({ 
          error: 'Í∑∏Î£π Ïù¥Î¶ÑÏùÄ ÌïÑÏàòÏûÖÎãàÎã§.' 
        });
      }
      
      if (!client_ids || !Array.isArray(client_ids) || client_ids.length === 0) {
        return res.status(400).json({ 
          error: 'ÏµúÏÜå Ìïú Í∞úÏùò ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º Í∑∏Î£πÏóê Ìè¨Ìï®Ìï¥Ïïº Ìï©ÎãàÎã§.' 
        });
      }

      const group = await GroupModel.update(id, { name, description, client_ids });
      
      // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
      socketService.emit('group_updated', group);
      
      logger.info(`Í∑∏Î£π ÏóÖÎç∞Ïù¥Ìä∏: ${name} (ID: ${id})`);
      res.json(group);
    } catch (error) {
      logger.error('Í∑∏Î£π ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error);
      next(error);
    }
  }

  // Í∑∏Î£π ÏÇ≠Ï†ú
  static async delete(req, res, next) {
    try {
      const { id } = req.params;
      
      const success = await GroupModel.delete(id);
      
      if (!success) {
        return res.status(404).json({ 
          error: 'Í∑∏Î£πÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.' 
        });
      }

      // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
      socketService.emit('group_deleted', { id: parseInt(id) });
      
      logger.info(`Í∑∏Î£π ÏÇ≠Ï†ú: ID ${id}`);
      res.json({ message: 'Í∑∏Î£πÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.' });
    } catch (error) {
      logger.error('Í∑∏Î£π ÏÇ≠Ï†ú Ïã§Ìå®:', error);
      next(error);
    }
  }
}

module.exports = GroupController;
```

### 10. controllers/presetController.js
```javascript
const PresetModel = require('../models/Preset');
const ExecutionService = require('../services/executionService');
const socketService = require('../services/socketService');
const logger = require('../utils/logger');

class PresetController {
  // Î™®Îì† ÌîÑÎ¶¨ÏÖã Ï°∞Ìöå
  static async getAll(req, res, next) {
    try {
      const presets = await PresetModel.findAll();
      res.json(presets);
    } catch (error) {
      logger.error('ÌîÑÎ¶¨ÏÖã Ï°∞Ìöå Ïã§Ìå®:', error);
      next(error);
    }
  }

  // ÌîÑÎ¶¨ÏÖã ÏÉùÏÑ±
  static async create(req, res, next) {
    try {
      const { name, description, target_group_id, client_commands } = req.body;
      
      // Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
      if (!name || !target_group_id || !client_commands || Object.keys(client_commands).length === 0) {
        return res.status(400).json({ 
          error: 'ÌîÑÎ¶¨ÏÖã Ïù¥Î¶Ñ, ÎåÄÏÉÅ Í∑∏Î£π, Î™ÖÎ†πÏñ¥Îäî ÌïÑÏàòÏûÖÎãàÎã§.' 
        });
      }

      const preset = await PresetModel.create({
        name, description, target_group_id, client_commands
      });
      
      // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
      socketService.emit('preset_added', preset);
      
      logger.info(`ÏÉà ÌîÑÎ¶¨ÏÖã ÏÉùÏÑ±: ${name}`);
      res.status(201).json(preset);
    } catch (error) {
      logger.error('ÌîÑÎ¶¨ÏÖã ÏÉùÏÑ± Ïã§Ìå®:', error);
      next(error);
    }
  }

  // ÌîÑÎ¶¨ÏÖã ÏóÖÎç∞Ïù¥Ìä∏
  static async update(req, res, next) {
    try {
      const { id } = req.params;
      const { name, description, target_group_id, client_commands } = req.body;
      
      if (!name || !target_group_id || !client_commands || Object.keys(client_commands).length === 0) {
        return res.status(400).json({ 
          error: 'ÌîÑÎ¶¨ÏÖã Ïù¥Î¶Ñ, ÎåÄÏÉÅ Í∑∏Î£π, Î™ÖÎ†πÏñ¥Îäî ÌïÑÏàòÏûÖÎãàÎã§.' 
        });
      }

      const preset = await PresetModel.update(id, {
        name, description, target_group_id, client_commands
      });
      
      // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
      socketService.emit('preset_updated', preset);
      
      logger.info(`ÌîÑÎ¶¨ÏÖã ÏóÖÎç∞Ïù¥Ìä∏: ${name} (ID: ${id})`);
      res.json(preset);
    } catch (error) {
      if (error.message === 'ÌîÑÎ¶¨ÏÖãÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.') {
        return res.status(404).json({ error: error.message });
      }
      logger.error('ÌîÑÎ¶¨ÏÖã ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error);
      next(error);
    }
  }

  // ÌîÑÎ¶¨ÏÖã ÏÇ≠Ï†ú
  static async delete(req, res, next) {
    try {
      const { id } = req.params;
      
      const success = await PresetModel.delete(id);
      
      if (!success) {
        return res.status(404).json({ 
          error: 'ÌîÑÎ¶¨ÏÖãÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.' 
        });
      }

      // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
      socketService.emit('preset_deleted', { id: parseInt(id) });
      
      logger.info(`ÌîÑÎ¶¨ÏÖã ÏÇ≠Ï†ú: ID ${id}`);
      res.json({ message: 'ÌîÑÎ¶¨ÏÖãÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.' });
    } catch (error) {
      logger.error('ÌîÑÎ¶¨ÏÖã ÏÇ≠Ï†ú Ïã§Ìå®:', error);
      next(error);
    }
  }

  // ÌîÑÎ¶¨ÏÖã Ïã§Ìñâ
  static async execute(req, res, next) {
    try {
      const { id } = req.params;
      
      const result = await ExecutionService.executePreset(id);
      
      logger.info(`ÌîÑÎ¶¨ÏÖã Ïã§Ìñâ: ID ${id}, ÏÑ±Í≥µ ${result.summary.successful}Í∞ú, Ïã§Ìå® ${result.summary.failed}Í∞ú`);
      res.json(result);
    } catch (error) {
      if (error.message === 'ÌîÑÎ¶¨ÏÖãÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.') {
        return res.status(404).json({ error: error.message });
      }
      logger.error('ÌîÑÎ¶¨ÏÖã Ïã§Ìñâ Ïã§Ìå®:', error);
      next(error);
    }
  }

  // ÌîÑÎ¶¨ÏÖã Ï†ïÏßÄ
  static async stop(req, res, next) {
    try {
      const { id } = req.params;
      
      const result = await ExecutionService.stopPreset(id);
      
      logger.info(`ÌîÑÎ¶¨ÏÖã Ï†ïÏßÄ: ID ${id}, Ï†ïÏßÄ ${result.summary.stopped}Í∞ú`);
      res.json(result);
    } catch (error) {
      if (error.message === 'ÌîÑÎ¶¨ÏÖãÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.') {
        return res.status(404).json({ error: error.message });
      }
      logger.error('ÌîÑÎ¶¨ÏÖã Ï†ïÏßÄ Ïã§Ìå®:', error);
      next(error);
    }
  }

  // ÌîÑÎ¶¨ÏÖã ÏÉÅÌÉú Ï°∞Ìöå
  static async getStatus(req, res, next) {
    try {
      const { id } = req.params;
      
      const status = await ExecutionService.getPresetStatus(id);
      
      res.json(status);
    } catch (error) {
      if (error.message === 'ÌîÑÎ¶¨ÏÖãÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.') {
        return res.status(404).json({ error: error.message });
      }
      logger.error('ÌîÑÎ¶¨ÏÖã ÏÉÅÌÉú Ï°∞Ìöå Ïã§Ìå®:', error);
      next(error);
    }
  }
}

module.exports = PresetController;
```

### 11. services/socketService.js
```javascript
const socketIo = require('socket.io');
const ClientModel = require('../models/Client');
const logger = require('../utils/logger');
const config = require('../config/server');

class SocketService {
  constructor() {
    this.io = null;
    this.connectedClients = new Map();
    this.clientTimeouts = new Map();
  }

  initialize(server) {
    this.io = socketIo(server, config.socket);
    
    this.io.on('connection', (socket) => {
      logger.info(`ÏÜåÏºì Ïó∞Í≤∞: ${socket.id}`);
      this.handleConnection(socket);
    });
    
    // Ï£ºÍ∏∞Ï†ÅÏù∏ ÏÉÅÌÉú ÌôïÏù∏
    this.startHealthCheck();
    this.startOfflineCheck();
    
    logger.info('Socket.IO ÏÑúÎπÑÏä§ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
  }

  handleConnection(socket) {
    // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îì±Î°ù
    socket.on('register_client', (data) => this.handleRegister(socket, data));
    
    // ÌïòÌä∏ÎπÑÌä∏
    socket.on('heartbeat', (data) => this.handleHeartbeat(socket, data));
    
    // ÌîÑÎ°úÏÑ∏Ïä§ ÏÉÅÌÉú
    socket.on('current_process_status', (data) => this.handleProcessStatus(socket, data));
    socket.on('process_status', (data) => this.handleProcessStatusUpdate(socket, data));
    
    // Ïã§Ìñâ Í≤∞Í≥º
    socket.on('execution_result', (data) => this.handleExecutionResult(socket, data));
    socket.on('stop_result', (data) => this.handleStopResult(socket, data));
    
    // Ïó∞Í≤∞ ÌôïÏù∏ ÏùëÎãµ
    socket.on('connection_check_response', (data) => this.handleConnectionCheckResponse(socket, data));
    
    // Ïó∞Í≤∞ Ìï¥Ï†ú
    socket.on('disconnect', () => this.handleDisconnect(socket));
  }

  async handleRegister(socket, data) {
    try {
      const { name, clientType = 'python', ip_address } = data;
      const clientIP = ip_address || this.normalizeIP(socket.handshake.address || '127.0.0.1');
      
      socket.clientType = clientType;
      socket.clientName = name;
      
      // Í∏∞Ï°¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï∞æÍ∏∞
      let client = await ClientModel.findByIP(clientIP);
      
      if (client) {
        socket.clientName = client.name;
        logger.info(`Í∏∞Ï°¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î∞úÍ≤¨: ${client.name} (ID: ${client.id})`);
      } else {
        // ÏÉà ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îì±Î°ù
        client = await ClientModel.create({ name, ip_address: clientIP });
        logger.info(`ÏÉà ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îì±Î°ù: ${name} (ID: ${client.id})`);
      }
      
      // ÏÜåÏºì Ïó∞Í≤∞ Í¥ÄÎ¶¨
      this.registerSocket(client.name, socket);
      
      // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      await ClientModel.updateStatus(client.id, 'online');
      this.emit('client_status_changed', { 
        id: client.id, 
        name: client.name, 
        status: 'online' 
      });
      
    } catch (error) {
      logger.error('ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îì±Î°ù Ïã§Ìå®:', error);
      socket.emit('registration_failed', { reason: error.message });
    }
  }

  async handleHeartbeat(socket, data) {
    try {
      const { clientName, ip_address, timestamp } = data;
      const clientIP = ip_address || this.normalizeIP(socket.handshake.address || '127.0.0.1');
      
      // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
      const client = await ClientModel.updateHeartbeat(clientName, clientIP);
      
      if (client) {
        // ÏÜåÏºì Ïó∞Í≤∞ Í¥ÄÎ¶¨
        this.registerSocket(client.name, socket);
        socket.clientName = client.name;
        
        // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        await ClientModel.updateStatus(client.id, 'online');
        this.emit('client_status_changed', { 
          id: client.id, 
          name: client.name, 
          status: 'online' 
        });
        
        // ÌïòÌä∏ÎπÑÌä∏ ÏùëÎãµ
        socket.emit('heartbeat_response', {
          status: 'ok',
          timestamp: new Date().toISOString(),
          message: 'ÌïòÌä∏ÎπÑÌä∏ ÏàòÏã† ÏôÑÎ£å'
        });
      }
    } catch (error) {
      logger.error('ÌïòÌä∏ÎπÑÌä∏ Ï≤òÎ¶¨ Ïã§Ìå®:', error);
    }
  }

  async handleProcessStatus(socket, data) {
    const { clientName, running_process_count, running_processes, status } = data;
    logger.info(`ÌîÑÎ°úÏÑ∏Ïä§ ÏÉÅÌÉú: ${clientName} - ${running_process_count}Í∞ú Ïã§Ìñâ Ï§ë`);
    
    try {
      const client = await ClientModel.findByName(clientName);
      if (client) {
        const newStatus = running_process_count > 0 ? 'running' : 'online';
        await ClientModel.updateStatus(client.id, newStatus);
        
        this.emit('client_status_changed', {
          id: client.id,
          name: clientName,
          status: newStatus,
          running_process_count,
          running_processes
        });
      }
    } catch (error) {
      logger.error('ÌîÑÎ°úÏÑ∏Ïä§ ÏÉÅÌÉú Ï≤òÎ¶¨ Ïã§Ìå®:', error);
    }
  }

  async handleExecutionResult(socket, data) {
    const { executionId, clientName, status, result } = data;
    logger.info(`Ïã§Ìñâ Í≤∞Í≥º: ${clientName} - ${status}`);
    
    // Ïã§Ìñâ ÌûàÏä§ÌÜ†Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
    if (executionId) {
      const ExecutionModel = require('../models/Execution');
      await ExecutionModel.updateStatus(executionId, status, result);
      this.emit('execution_updated', { executionId, status, result });
    }
    
    // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    if (clientName) {
      const client = await ClientModel.findByName(clientName);
      if (client) {
        await ClientModel.updateStatus(client.id, 'online');
        this.emit('client_status_changed', { 
          name: clientName, 
          status: 'online',
          reason: 'Î™ÖÎ†π Ïã§Ìñâ ÏôÑÎ£å'
        });
      }
    }
  }

  handleDisconnect(socket) {
    const clientType = socket.clientType || 'Unknown';
    const clientName = socket.clientName || 'Unknown';
    
    logger.info(`ÏÜåÏºì Ïó∞Í≤∞ Ìï¥Ï†ú: ${clientName} (${clientType})`);
    
    if (socket.clientName) {
      // Ïó∞Í≤∞ Ìï¥Ï†ú Ï≤òÎ¶¨
      this.handleClientDisconnect(socket.clientName);
    }
  }

  handleClientDisconnect(clientName) {
    const currentSocket = this.connectedClients.get(clientName);
    if (currentSocket && currentSocket.id === socket.id) {
      this.connectedClients.delete(clientName);
      
      // ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï (Ïû¨Ïó∞Í≤∞ ÎåÄÍ∏∞)
      const timeout = setTimeout(async () => {
        const checkSocket = this.connectedClients.get(clientName);
        if (!checkSocket || !checkSocket.connected) {
          const client = await ClientModel.findByName(clientName);
          if (client) {
            await ClientModel.updateStatus(client.id, 'offline');
            this.emit('client_status_changed', { 
              name: clientName, 
              status: 'offline' 
            });
          }
        }
      }, 5000); // 5Ï¥à ÎåÄÍ∏∞
      
      this.clientTimeouts.set(clientName, timeout);
    }
  }

  registerSocket(clientName, socket) {
    // Í∏∞Ï°¥ ÏÜåÏºì Ï†ïÎ¶¨
    this.cleanupSocket(clientName);
    
    // ÏÉà ÏÜåÏºì Îì±Î°ù
    this.connectedClients.set(clientName, socket);
    socket.clientName = clientName;
    
    // ÌÉÄÏûÑÏïÑÏõÉ ÌÅ¥Î¶¨Ïñ¥
    this.clearTimeout(clientName);
  }

  cleanupSocket(clientName) {
    const oldSocket = this.connectedClients.get(clientName);
    if (oldSocket && oldSocket.connected && oldSocket.id !== socket.id) {
      oldSocket.disconnect();
    }
  }

  clearTimeout(clientName) {
    const timeout = this.clientTimeouts.get(clientName);
    if (timeout) {
      clearTimeout(timeout);
      this.clientTimeouts.delete(clientName);
    }
  }

  normalizeIP(ip) {
    if (ip.startsWith('::ffff:')) {
      return ip.substring(7);
    }
    if (ip === '::1') {
      return '127.0.0.1';
    }
    return ip;
  }

  // Ïô∏Î∂Ä Ìò∏Ï∂úÏö© Î©îÏÑúÎìú
  emit(event, data) {
    if (this.io) {
      this.io.emit(event, data);
    }
  }

  emitToClient(clientName, event, data) {
    const socket = this.connectedClients.get(clientName);
    if (socket && socket.connected) {
      socket.emit(event, data);
      return true;
    }
    return false;
  }

  getConnectedClients() {
    return Array.from(this.connectedClients.keys());
  }

  isClientConnected(clientName) {
    const socket = this.connectedClients.get(clientName);
    return socket && socket.connected;
  }

  // Ï£ºÍ∏∞Ï†ÅÏù∏ ÏÉÅÌÉú ÌôïÏù∏
  startHealthCheck() {
    setInterval(async () => {
      const onlineClients = await ClientModel.findOnlineClients();
      
      for (const client of onlineClients) {
        const socket = this.connectedClients.get(client.name);
        if (socket && socket.connected) {
          socket.emit('connection_check', {
            clientName: client.name,
            timestamp: new Date().toISOString()
          });
        } else {
          // ÏÜåÏºìÏù¥ ÏóÜÏúºÎ©¥ Ïò§ÌîÑÎùºÏù∏ Ï≤òÎ¶¨
          await ClientModel.updateStatus(client.id, 'offline');
          this.emit('client_status_changed', { 
            name: client.name, 
            status: 'offline' 
          });
        }
      }
    }, config.monitoring.connectionCheckInterval);
  }

  // Ïò§ÌîÑÎùºÏù∏ Ï≤òÎ¶¨
  startOfflineCheck() {
    setInterval(async () => {
      const offlineCount = await ClientModel.markOfflineByTimeout(config.monitoring.offlineTimeout);
      
      if (offlineCount > 0) {
        logger.info(`${offlineCount}Í∞ú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º Ïò§ÌîÑÎùºÏù∏ÏúºÎ°ú Î≥ÄÍ≤Ω`);
        this.emit('clients_offline_updated');
      }
    }, config.monitoring.offlineTimeout);
  }
}

module.exports = new SocketService();
```

### 12. services/executionService.js
```javascript
const PresetModel = require('../models/Preset');
const ClientModel = require('../models/Client');
const socketService = require('./socketService');
const logger = require('../utils/logger');

class ExecutionService {
  // ÌîÑÎ¶¨ÏÖã Ïã§Ìñâ
  static async executePreset(presetId) {
    logger.info(`ÌîÑÎ¶¨ÏÖã Ïã§Ìñâ ÏãúÏûë: ID ${presetId}`);
    
    // ÌîÑÎ¶¨ÏÖã Ï†ïÎ≥¥ Ï°∞Ìöå
    const preset = await PresetModel.findById(presetId);
    if (!preset) {
      throw new Error('ÌîÑÎ¶¨ÏÖãÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
    }
    
    // ÎåÄÏÉÅ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå
    const clients = await PresetModel.getTargetClients(presetId);
    const onlineClients = clients.filter(c => c.status !== 'offline');
    
    if (onlineClients.length === 0) {
      throw new Error('Ïã§Ìñâ Í∞ÄÎä•Ìïú Ïò®ÎùºÏù∏ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§.');
    }
    
    // Ïã§Ìñâ Í≤∞Í≥º ÏàòÏßë
    const executionResults = [];
    const warnings = [];
    
    // Í∞Å ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïóê Î™ÖÎ†π Ï†ÑÏÜ°
    for (const client of clients) {
      const command = preset.client_commands[client.id] || preset.client_commands[client.name];
      
      if (!command) {
        warnings.push(`ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ${client.name}Ïóê ÎåÄÌïú Î™ÖÎ†πÏñ¥Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.`);
        continue;
      }
      
      const sent = socketService.emitToClient(client.name, 'execute_command', {
        clientName: client.name,
        command: command,
        presetId: preset.id
      });
      
      if (sent) {
        // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        await ClientModel.update(client.id, { 
          status: 'running',
          current_preset_id: preset.id
        });
        
        // Ïã§Ìñâ ÌûàÏä§ÌÜ†Î¶¨ Í∏∞Î°ù
        await PresetModel.addExecutionHistory(preset.id, client.id, 'executing');
        
        executionResults.push({
          clientId: client.id,
          clientName: client.name,
          status: 'running'
        });
      } else {
        warnings.push(`ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ${client.name}Í∞Ä Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.`);
        await PresetModel.addExecutionHistory(preset.id, client.id, 'failed_offline');
      }
    }
    
    // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
    socketService.emit('preset_executed', {
      presetId: preset.id,
      presetName: preset.name,
      clients: executionResults,
      warnings: warnings
    });
    
    return {
      message: 'ÌîÑÎ¶¨ÏÖãÏù¥ Ïã§ÌñâÎêòÏóàÏäµÎãàÎã§.',
      preset: preset,
      clients: executionResults,
      summary: {
        total: clients.length,
        online: onlineClients.length,
        offline: clients.length - onlineClients.length,
        executed: executionResults.length
      },
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }

  // ÌîÑÎ¶¨ÏÖã Ï†ïÏßÄ
  static async stopPreset(presetId) {
    logger.info(`ÌîÑÎ¶¨ÏÖã Ï†ïÏßÄ ÏãúÏûë: ID ${presetId}`);
    
    // ÌîÑÎ¶¨ÏÖã Ï†ïÎ≥¥ Ï°∞Ìöå
    const preset = await PresetModel.findById(presetId);
    if (!preset) {
      throw new Error('ÌîÑÎ¶¨ÏÖãÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
    }
    
    // ÎåÄÏÉÅ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï°∞Ìöå
    const clients = await PresetModel.getTargetClients(presetId);
    const stopResults = [];
    
    // Í∞Å ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïóê Ï†ïÏßÄ Î™ÖÎ†π Ï†ÑÏÜ°
    for (const client of clients) {
      const sent = socketService.emitToClient(client.name, 'stop_command', {
        clientName: client.name,
        presetId: preset.id
      });
      
      if (sent) {
        // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        await ClientModel.update(client.id, { 
          status: 'online',
          current_preset_id: null
        });
        
        stopResults.push({
          clientId: client.id,
          clientName: client.name,
          status: 'stopping'
        });
      }
    }
    
    // Socket.IO Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
    socketService.emit('preset_stopped', {
      presetId: preset.id,
      presetName: preset.name,
      clients: stopResults
    });
    
    return {
      message: 'ÌîÑÎ¶¨ÏÖã Ï†ïÏßÄ ÏöîÏ≤≠Ïù¥ Ï†ÑÏÜ°ÎêòÏóàÏäµÎãàÎã§.',
      preset: preset,
      clients: stopResults,
      summary: {
        total: clients.length,
        stopped: stopResults.length
      }
    };
  }

  // ÌîÑÎ¶¨ÏÖã ÏÉÅÌÉú Ï°∞Ìöå
  static async getPresetStatus(presetId) {
    const preset = await PresetModel.findById(presetId);
    if (!preset) {
      throw new Error('ÌîÑÎ¶¨ÏÖãÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
    }
    
    const clients = await PresetModel.getTargetClients(presetId);
    
    // Í∞Å ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïùò ÏÉÅÌÉú ÌåêÏ†ï
    let runningCount = 0;
    let onlineCount = 0;
    let offlineCount = 0;
    
    for (const client of clients) {
      if (client.status === 'running' && client.current_preset_id == presetId) {
        runningCount++;
      } else if (client.status === 'online') {
        onlineCount++;
      } else {
        offlineCount++;
      }
    }
    
    // ÌîÑÎ¶¨ÏÖã ÏÉÅÌÉú ÌåêÏ†ï
    let status = 'stopped';
    let statusColor = 'gray';
    
    if (runningCount > 0) {
      if (runningCount === clients.length) {
        status = 'running';
        statusColor = 'green';
      } else {
        status = 'partial';
        statusColor = 'yellow';
      }
    } else if (offlineCount === clients.length) {
      status = 'offline';
      statusColor = 'red';
    } else if (onlineCount > 0) {
      status = 'ready';
      statusColor = 'blue';
    }
    
    return {
      presetId: presetId,
      presetName: preset.name,
      status: status,
      statusColor: statusColor,
      summary: {
        total: clients.length,
        running: runningCount,
        online: onlineCount,
        offline: offlineCount
      },
      clients: clients.map(client => ({
        id: client.id,
        name: client.name,
        status: client.status,
        current_preset_id: client.current_preset_id,
        isRunningThisPreset: client.status === 'running' && client.current_preset_id == presetId
      }))
    };
  }
}

module.exports = ExecutionService;
```

### 13. routes/index.js
```javascript
const express = require('express');
const router = express.Router();

// ÎùºÏö∞Ìä∏ Î™®ÎìàÎì§
const clientRoutes = require('./clients');
const groupRoutes = require('./groups');
const presetRoutes = require('./presets');
const executionRoutes = require('./executions');

// Ìó¨Ïä§ Ï≤¥ÌÅ¨
router.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    server: 'UE CMS Server v2.0'
  });
});

// ÎùºÏö∞Ìä∏ Îì±Î°ù
router.use('/clients', clientRoutes);
router.use('/groups', groupRoutes);
router.use('/presets', presetRoutes);
router.use('/executions', executionRoutes);

// ÌîÑÎ°úÏÑ∏Ïä§ ÏÉÅÌÉú Ï°∞Ìöå
router.get('/process-status', (req, res) => {
  try {
    const processStatus = global.processStatus || new Map();
    const statusData = {};
    
    for (const [clientName, status] of processStatus) {
      statusData[clientName] = status;
    }
    
    res.json({
      success: true,
      data: statusData,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ÌäπÏ†ï ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïùò ÌîÑÎ°úÏÑ∏Ïä§ ÏÉÅÌÉú Ï°∞Ìöå
router.get('/process-status/:clientName', (req, res) => {
  try {
    const { clientName } = req.params;
    const processStatus = global.processStatus || new Map();
    
    if (processStatus.has(clientName)) {
      res.json({
        success: true,
        data: processStatus.get(clientName),
        timestamp: new Date().toISOString()
      });
    } else {
      res.status(404).json({
        success: false,
        error: 'ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïùò ÌîÑÎ°úÏÑ∏Ïä§ ÏÉÅÌÉúÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.'
      });
    }
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

module.exports = router;
```

### 14. routes/clients.js
```javascript
const express = require('express');
const router = express.Router();
const ClientController = require('../controllers/clientController');
const asyncHandler = require('../middleware/asyncHandler');

// ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î™©Î°ù Ï°∞Ìöå
router.get('/', asyncHandler(ClientController.getAll));

// ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
router.post('/', asyncHandler(ClientController.create));

// ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏàòÏ†ï
router.put('/:id', asyncHandler(ClientController.update));

// ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÇ≠Ï†ú
router.delete('/:id', asyncHandler(ClientController.delete));

// MAC Ï£ºÏÜå ÏóÖÎç∞Ïù¥Ìä∏ (IDÎ°ú)
router.put('/:id/mac-address', asyncHandler(ClientController.updateMacAddress));

// ÌïòÌä∏ÎπÑÌä∏
router.post('/heartbeat', asyncHandler(ClientController.heartbeat));

module.exports = router;
```

### 15. routes/groups.js
```javascript
const express = require('express');
const router = express.Router();
const GroupController = require('../controllers/groupController');
const asyncHandler = require('../middleware/asyncHandler');

// Í∑∏Î£π Î™©Î°ù Ï°∞Ìöå
router.get('/', asyncHandler(GroupController.getAll));

// Í∑∏Î£π ÏÉùÏÑ±
router.post('/', asyncHandler(GroupController.create));

// Í∑∏Î£π ÏàòÏ†ï
router.put('/:id', asyncHandler(GroupController.update));

// Í∑∏Î£π ÏÇ≠Ï†ú
router.delete('/:id', asyncHandler(GroupController.delete));

module.exports = router;
```

### 16. routes/presets.js
```javascript
const express = require('express');
const router = express.Router();
const PresetController = require('../controllers/presetController');
const asyncHandler = require('../middleware/asyncHandler');

// ÌîÑÎ¶¨ÏÖã Î™©Î°ù Ï°∞Ìöå
router.get('/', asyncHandler(PresetController.getAll));

// ÌîÑÎ¶¨ÏÖã ÏÉùÏÑ±
router.post('/', asyncHandler(PresetController.create));

// ÌîÑÎ¶¨ÏÖã ÏàòÏ†ï
router.put('/:id', asyncHandler(PresetController.update));

// ÌîÑÎ¶¨ÏÖã ÏÇ≠Ï†ú
router.delete('/:id', asyncHandler(PresetController.delete));

// ÌîÑÎ¶¨ÏÖã Ïã§Ìñâ
router.post('/:id/execute', asyncHandler(PresetController.execute));

// ÌîÑÎ¶¨ÏÖã Ï†ïÏßÄ
router.post('/:id/stop', asyncHandler(PresetController.stop));

// ÌîÑÎ¶¨ÏÖã ÏÉÅÌÉú Ï°∞Ìöå
router.get('/:id/status', asyncHandler(PresetController.getStatus));

module.exports = router;
```

### 17. routes/executions.js
```javascript
const express = require('express');
const router = express.Router();
const ExecutionController = require('../controllers/executionController');
const asyncHandler = require('../middleware/asyncHandler');

// Ïã§Ìñâ Ïù¥Î†• Ï°∞Ìöå
router.get('/', asyncHandler(ExecutionController.getAll));

// Ïã§Ìñâ ÌÜµÍ≥Ñ Ï°∞Ìöå
router.get('/statistics', asyncHandler(ExecutionController.getStatistics));

module.exports = router;
```

### 18. controllers/executionController.js
```javascript
const ExecutionModel = require('../models/Execution');
const logger = require('../utils/logger');

class ExecutionController {
  // Ïã§Ìñâ Ïù¥Î†• Ï°∞Ìöå
  static async getAll(req, res, next) {
    try {
      const { limit = 50 } = req.query;
      const executions = await ExecutionModel.findAll(parseInt(limit));
      res.json(executions);
    } catch (error) {
      logger.error('Ïã§Ìñâ Ïù¥Î†• Ï°∞Ìöå Ïã§Ìå®:', error);
      next(error);
    }
  }

  // Ïã§Ìñâ ÌÜµÍ≥Ñ Ï°∞Ìöå
  static async getStatistics(req, res, next) {
    try {
      const stats = await ExecutionModel.getStatistics();
      res.json(stats);
    } catch (error) {
      logger.error('Ïã§Ìñâ ÌÜµÍ≥Ñ Ï°∞Ìöå Ïã§Ìå®:', error);
      next(error);
    }
  }
}

module.exports = ExecutionController;
```

### 19. middleware/asyncHandler.js
```javascript
// ÎπÑÎèôÍ∏∞ Ìï®Ïàò ÎûòÌçº
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

module.exports = asyncHandler;
```

### 20. middleware/errorHandler.js
```javascript
const logger = require('../utils/logger');

// Ïª§Ïä§ÌÖÄ ÏóêÎü¨ ÌÅ¥ÎûòÏä§
class AppError extends Error {
  constructor(message, statusCode = 500) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;
    Error.captureStackTrace(this, this.constructor);
  }
}

// ÏóêÎü¨ Ìï∏Îì§Îü¨
const errorHandler = (err, req, res, next) => {
  let { statusCode = 500, message } = err;
  
  // Î°úÍπÖ
  if (statusCode >= 500) {
    logger.error('ÏÑúÎ≤Ñ ÏóêÎü¨:', err);
  } else {
    logger.warn('ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏóêÎü¨:', err.message);
  }
  
  // Í∞úÎ∞ú ÌôòÍ≤ΩÏóêÏÑúÎäî ÏóêÎü¨ Ïä§ÌÉù Ìè¨Ìï®
  const response = {
    success: false,
    error: message
  };
  
  if (process.env.NODE_ENV === 'development') {
    response.stack = err.stack;
  }
  
  res.status(statusCode).json(response);
};

// 404 Ìï∏Îì§Îü¨
const notFoundHandler = (req, res, next) => {
  const error = new AppError(`Cannot find ${req.originalUrl}`, 404);
  next(error);
};

module.exports = {
  AppError,
  errorHandler,
  notFoundHandler
};
```

### 21. utils/logger.js
```javascript
const winston = require('winston');
const path = require('path');
const config = require('../config/server');

// Î°úÍ∑∏ Ìè¨Îß∑ Ï†ïÏùò
const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

// ÏΩòÏÜî Ï∂úÎ†• Ìè¨Îß∑
const consoleFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.timestamp({ format: 'HH:mm:ss' }),
  winston.format.printf(({ timestamp, level, message, ...meta }) => {
    let msg = `${timestamp} [${level}]: ${message}`;
    if (Object.keys(meta).length > 0) {
      msg += ` ${JSON.stringify(meta)}`;
    }
    return msg;
  })
);

// Î°úÍ±∞ ÏÉùÏÑ±
const logger = winston.createLogger({
  level: config.logging.level,
  format: logFormat,
  transports: [
    // ÏóêÎü¨ Î°úÍ∑∏ ÌååÏùº
    new winston.transports.File({
      filename: path.join('logs', 'error.log'),
      level: 'error',
      maxsize: 10485760, // 10MB
      maxFiles: 5
    }),
    // Ï†ÑÏ≤¥ Î°úÍ∑∏ ÌååÏùº
    new winston.transports.File({
      filename: path.join('logs', 'app.log'),
      maxsize: 10485760, // 10MB
      maxFiles: 5
    })
  ]
});

// Í∞úÎ∞ú ÌôòÍ≤ΩÏóêÏÑúÎäî ÏΩòÏÜî Ï∂úÎ†• Ï∂îÍ∞Ä
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: consoleFormat
  }));
}

module.exports = logger;
```

### 22. ÏÉàÎ°úÏö¥ app.js (Î©îÏù∏ ÌååÏùº)
```javascript
const express = require('express');
const http = require('http');
const cors = require('cors');
const path = require('path');

// ÏÑ§Ï†ï Î∞è Ïú†Ìã∏Î¶¨Ìã∞
const config = require('./config/server');
const database = require('./config/database');
const logger = require('./utils/logger');

// ÎØ∏Îì§Ïõ®Ïñ¥
const { errorHandler, notFoundHandler } = require('./middleware/errorHandler');

// ÏÑúÎπÑÏä§
const socketService = require('./services/socketService');

// ÎùºÏö∞Ìä∏
const routes = require('./routes');

// Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
const { runMigrations } = require('./db/migrations');

// Express Ïï± ÏÉùÏÑ±
const app = express();

// ÎØ∏Îì§Ïõ®Ïñ¥ ÏÑ§Ï†ï
app.use(cors(config.cors));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, 'public')));

// API ÎùºÏö∞Ìä∏
app.use('/api', routes);

// Í∏∞Î≥∏ ÎùºÏö∞Ìä∏ - Ïõπ UI ÏÑúÎπô
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// 404 Ìï∏Îì§Îü¨
app.use(notFoundHandler);

// ÏóêÎü¨ Ìï∏Îì§Îü¨
app.use(errorHandler);

// ÏÑúÎ≤Ñ ÏÉùÏÑ±
const server = http.createServer(app);

// ÏÑúÎ≤Ñ ÏãúÏûë
async function startServer() {
  try {
    // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî
    await database.initialize();
    
    // ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìñâ
    await runMigrations();
    
    // Socket.IO Ï¥àÍ∏∞Ìôî
    socketService.initialize(server);
    
    // ÏÑúÎ≤Ñ ÏãúÏûë
    server.listen(config.server.port, () => {
      logger.info(`üöÄ UE CMS Server ÏãúÏûëÎê®`);
      logger.info(`üì± Ïõπ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§: http://localhost:${config.server.port}`);
      logger.info(`üîå Socket.IO ÌôúÏÑ±ÌôîÎê®`);
    });
    
  } catch (error) {
    logger.error('ÏÑúÎ≤Ñ ÏãúÏûë Ïã§Ìå®:', error);
    process.exit(1);
  }
}

// Graceful shutdown
process.on('SIGINT', async () => {
  logger.info('ÏÑúÎ≤Ñ Ï¢ÖÎ£å ÏãúÏûë...');
  
  try {
    // ÏÑúÎ≤Ñ Ï¢ÖÎ£å
    server.close();
    
    // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ï¢ÖÎ£å
    await database.close();
    
    logger.info('ÏÑúÎ≤Ñ Ï†ïÏÉÅ Ï¢ÖÎ£åÎê®');
    process.exit(0);
  } catch (error) {
    logger.error('ÏÑúÎ≤Ñ Ï¢ÖÎ£å Ï§ë Ïò§Î•ò:', error);
    process.exit(1);
  }
});

// Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ ÏóêÎü¨ Ìï∏Îì§ÎßÅ
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception:', error);
  process.exit(1);
});

// ÏÑúÎ≤Ñ ÏãúÏûë
startServer();
```

### 23. package.json ÏóÖÎç∞Ïù¥Ìä∏
```json
{
  "name": "switchboard-plus-server",
  "version": "2.0.0",
  "description": "Switchboard Plus v2 Server",
  "main": "app.js",
  "scripts": {
    "start": "node app.js",
    "dev": "nodemon app.js",
    "test": "jest",
    "lint": "eslint .",
    "db:check": "node scripts/check_db.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "sqlite3": "^5.1.6",
    "socket.io": "^4.6.1",
    "cors": "^2.8.5",
    "winston": "^3.11.0",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "eslint": "^8.54.0",
    "jest": "^29.7.0"
  },
  "engines": {
    "node": ">=14.0.0"
  }
}
```

### 24. .env ÌååÏùº (ÌôòÍ≤Ω Î≥ÄÏàò)
```env
# ÏÑúÎ≤Ñ ÏÑ§Ï†ï
PORT=8000
HOST=localhost
NODE_ENV=development

# Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§
DB_FILE=./ue_cms.db

# Î°úÍπÖ
LOG_LEVEL=info

# CORS
CORS_ORIGIN=*
```

### 25. ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïä§ÌÅ¨Î¶ΩÌä∏
```bash
#!/bin/bash
# migrate.sh

echo "üîÑ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖ Ï§ë..."
cp ue_cms.db ue_cms.db.backup.$(date +%Y%m%d_%H%M%S)

echo "üì¶ ÏùòÏ°¥ÏÑ± ÏÑ§Ïπò Ï§ë..."
npm install

echo "üöÄ ÏÑúÎ≤Ñ ÏãúÏûë..."
npm start
```

## üìù Ï†ÅÏö© Í∞ÄÏù¥Îìú

### 1Îã®Í≥Ñ: Î∞±ÏóÖ
```bash
# ÌòÑÏû¨ ÏΩîÎìúÏôÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖ
cp -r server server_backup
cp server/ue_cms.db server/ue_cms.db.backup
```

### 2Îã®Í≥Ñ: ÏÉà Íµ¨Ï°∞ ÏÉùÏÑ±
```bash
cd server
mkdir -p config db models controllers services routes middleware utils logs
```

### 3Îã®Í≥Ñ: ÌååÏùº Î≥µÏÇ¨
ÏúÑÏùò Í∞Å ÌååÏùºÏùÑ Ìï¥Îãπ Í≤ΩÎ°úÏóê ÏÉùÏÑ±ÌïòÍ≥† ÎÇ¥Ïö©ÏùÑ Î≥µÏÇ¨Ìï©ÎãàÎã§.

### 4Îã®Í≥Ñ: package.json ÏóÖÎç∞Ïù¥Ìä∏
```bash
npm install winston dotenv
```

### 5Îã®Í≥Ñ: ÌÖåÏä§Ìä∏
```bash
# Í∞úÎ∞ú Î™®ÎìúÎ°ú Ïã§Ìñâ
npm run dev

# Î°úÍ∑∏ ÌôïÏù∏
tail -f logs/app.log
```

### 6Îã®Í≥Ñ: Ï†êÏßÑÏ†Å ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
Í∏∞Ï°¥ app.jsÎ•º app.old.jsÎ°ú Ïù¥Î¶Ñ Î≥ÄÍ≤Ω ÌõÑ, ÏÉà app.jsÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§.

## ‚úÖ ÏµúÏ†ÅÌôî Ìö®Í≥º

1. **ÏΩîÎìú Í∞ÄÎèÖÏÑ±**: 3000Ï§Ñ ‚Üí Í∏∞Îä•Î≥Ñ 100~300Ï§Ñ ÌååÏùºÎ°ú Î∂ÑÎ¶¨
2. **Ïú†ÏßÄÎ≥¥ÏàòÏÑ±**: Í∞Å Í∏∞Îä•Ïù¥ ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú Í¥ÄÎ¶¨Îê®
3. **ÏÑ±Îä• Ìñ•ÏÉÅ**: ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨, Ìä∏ÎûúÏû≠ÏÖò, DB ÏµúÏ†ÅÌôî
4. **ÏïàÏ†ïÏÑ±**: Ï≤¥Í≥ÑÏ†ÅÏù∏ ÏóêÎü¨ Ï≤òÎ¶¨, Î°úÍπÖ ÏãúÏä§ÌÖú
5. **ÌôïÏû•ÏÑ±**: ÏÉà Í∏∞Îä• Ï∂îÍ∞ÄÍ∞Ä Îß§Ïö∞ Ïö©Ïù¥Ìï®

Ïù¥Ï†ú Í∞Å ÌååÏùºÏùÑ Î≥µÏÇ¨Ìï¥ÏÑú ÏÇ¨Ïö©ÌïòÏãúÎ©¥ Îê©ÎãàÎã§!