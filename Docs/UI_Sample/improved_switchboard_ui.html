<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Switchboard Plus v2 - nDisplay Control</title>
    <style>
        /* 🎨 CSS 변수 정의 (라이트/다크 테마) */
        :root {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f8fafc;
            --text-primary: #333333;
            --text-secondary: #1e293b;
            --text-muted: #64748b;
            --border-color: #e2e8f0;
            --border-hover: #3b82f6;
            --shadow-color: rgba(0,0,0,0.1);
            --modal-overlay: rgba(0,0,0,0.5);
            
            /* 클라이언트 상태 색상 */
            --client-online: #fef3c7;
            --client-running: #dcfce7;
            --client-offline: #fef2f2;
            
            /* 버튼 색상 */
            --btn-primary: #22c55e;
            --btn-primary-hover: #16a34a;
            --btn-danger: #ef4444;
            --btn-danger-hover: #dc2626;
            --btn-secondary: #64748b;
            --btn-secondary-hover: #475569;
            
            /* 추가 색상 */
            --success-bg: #f0fdf4;
            --warning-bg: #fef3c7;
            --error-bg: #fef2f2;
            --info-bg: #f0f9ff;
        }

        /* 🌙 다크 테마 */
        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #e2e8f0;
            --text-muted: #94a3b8;
            --border-color: #334155;
            --border-hover: #3b82f6;
            --shadow-color: rgba(0,0,0,0.3);
            --modal-overlay: rgba(0,0,0,0.7);
            
            /* 다크 모드 클라이언트 상태 색상 */
            --client-online: #422006;
            --client-running: #14532d;
            --client-offline: #450a0a;
            
            /* 다크 모드 추가 색상 */
            --success-bg: #14532d;
            --warning-bg: #422006;
            --error-bg: #450a0a;
            --info-bg: #1e3a8a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* 🎨 헤더 */
        .header {
            background: linear-gradient(135deg, #4c1d95 0%, #6366f1 50%, #71717a 100%);
            color: white;
            padding: 12px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-info {
            display: flex;
            gap: 15px;
            font-size: 12px;
            align-items: center;
        }

        /* Socket 연결 상태 표시 */
        .socket-status {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .socket-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #22c55e;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .socket-indicator.disconnected {
            background: #ef4444;
            animation: none;
        }

        .settings-btn {
            background: rgba(255,255,255,0.15);
            border: none;
            color: white;
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .settings-btn:hover {
            background: rgba(255,255,255,0.25);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* 📊 통계 바 */
        .stats-bar {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 25px 30px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px var(--shadow-color);
            transition: background-color 0.3s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 30px;
            text-align: center;
        }

        .stat-item {
            padding: 5px;
        }

        .stat-value {
            font-size: 36px;
            font-weight: 700;
            color: #3b82f6;
            line-height: 1;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: 400;
        }

        /* 📋 메인 레이아웃 */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .section {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 1px 3px var(--shadow-color);
            transition: background-color 0.3s ease;
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* 🔘 버튼 스타일 */
        .btn {
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            padding: 0;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .btn-primary {
            background: var(--btn-primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--btn-primary-hover);
        }

        .btn-danger {
            background: var(--btn-danger);
            color: white;
        }

        .btn-danger:hover {
            background: var(--btn-danger-hover);
        }

        .btn-secondary {
            background: var(--btn-secondary);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--btn-secondary-hover);
        }

        /* 텍스트가 있는 버튼 */
        .btn-with-text {
            width: auto;
            padding: 6px 12px;
            font-size: 12px;
            min-width: 80px;
            height: 28px;
        }

        /* 일괄 제어 버튼 */
        .btn-bulk {
            width: auto;
            padding: 4px 8px;
            font-size: 11px;
            min-width: 60px;
            height: 26px;
        }

        /* 📝 프리셋 카드 */
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .preset-card {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
            position: relative;
        }

        .preset-card:hover {
            border-color: var(--border-hover);
            background: var(--bg-tertiary);
        }

        .preset-card.active {
            border-color: #22c55e;
            background: var(--success-bg);
        }

        .preset-checkbox {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 16px;
            height: 16px;
            z-index: 1;
        }

        .preset-content {
            flex: 1;
            margin-left: 24px;
        }

        .preset-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .preset-info {
            font-size: 11px;
            color: var(--text-muted);
            line-height: 1.3;
        }

        .preset-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        /* 👥 그룹 카드 */
        .group-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .group-card {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
            position: relative;
        }

        .group-card:hover {
            border-color: var(--border-hover);
            background: var(--bg-tertiary);
        }

        .group-checkbox {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 16px;
            height: 16px;
            z-index: 1;
        }

        .group-content {
            flex: 1;
            margin-left: 24px;
        }

        .group-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .group-info {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .group-clients {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .group-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
            align-items: center;
        }

        .client-tag {
            background: #22c55e;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 500;
        }

        /* 일괄 제어 UI */
        .bulk-controls {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s ease;
        }

        .selection-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .bulk-actions {
            display: flex;
            gap: 6px;
        }

        /* 🖥️ 디스플레이 서버 모니터링 */
        .client-monitor {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 1px 3px var(--shadow-color);
            transition: background-color 0.3s ease;
        }

        .monitor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .client-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }

        .client-item {
            background: var(--client-online);
            border-radius: 6px;
            padding: 12px 8px;
            text-align: center;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            border: 2px solid transparent;
        }

        .client-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .client-item.online {
            background: var(--client-online);
            border-color: #f59e0b;
        }

        .client-item.running {
            background: var(--client-running);
            border-color: #22c55e;
        }

        .client-item.offline {
            background: var(--client-offline);
            border-color: #ef4444;
            opacity: 0.7;
        }

        .client-icon {
            font-size: 24px;
            margin-bottom: 6px;
        }

        .client-name {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 2px;
            color: var(--text-secondary);
        }

        .client-ip {
            font-size: 10px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .client-status {
            font-size: 9px;
            color: var(--text-muted);
            font-weight: 500;
            margin-bottom: 4px;
        }

        /* 성능 메트릭 표시 */
        .client-metrics {
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px solid var(--border-color);
            font-size: 9px;
            color: var(--text-muted);
            line-height: 1.2;
        }

        .client-metrics.visible {
            display: block;
        }

        /* 실행 ID 표시 */
        .execution-id {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 8px;
            font-weight: 600;
        }

        /* 📊 실행 모니터링 섹션 */
        .execution-monitor {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 1px 3px var(--shadow-color);
            transition: background-color 0.3s ease;
        }

        .execution-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 400px;
            overflow-y: auto;
        }

        .execution-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            transition: all 0.2s ease;
        }

        .execution-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .execution-details {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .execution-targets {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
        }

        .target-client {
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 9px;
            font-weight: 500;
        }

        .target-client.success {
            background: var(--success-bg);
            color: #14532d;
        }

        .target-client.failed {
            background: var(--error-bg);
            color: #991b1b;
        }

        .target-client.pending {
            background: var(--warning-bg);
            color: #92400e;
        }

        .execution-status {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 600;
        }

        .execution-status.pending {
            background: var(--warning-bg);
            color: #92400e;
        }

        .execution-status.running {
            background: var(--info-bg);
            color: #1e40af;
        }

        .execution-status.completed {
            background: var(--success-bg);
            color: #14532d;
        }

        .execution-status.failed {
            background: var(--error-bg);
            color: #991b1b;
        }

        .execution-progress {
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }

        .execution-progress-bar {
            height: 100%;
            background: #3b82f6;
            transition: width 0.3s ease;
        }

        /* 모달 스타일 */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-overlay);
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;  /* 더 넓게 */
            width: 90%;
            max-height: 80%;
            overflow-y: auto;
            animation: modalSlideIn 0.3s ease;
            transition: background-color 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-header h3 {
            color: var(--text-secondary);
        }

        .close {
            font-size: 24px;
            cursor: pointer;
            color: var(--text-muted);
        }

        .close:hover {
            color: #ef4444;
        }

        /* 정보 섹션 */
        .info-section {
            margin-bottom: 20px;
        }

        .info-section h4 {
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--text-secondary);
        }

        .info-grid {
            display: grid;
            gap: 8px;
            font-size: 12px;
            color: var(--text-muted);
        }

        /* 버튼 그룹 */
        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* 위험 구역 스타일 */
        .danger-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #fee2e2;
        }

        .warning-text {
            font-size: 11px;
            color: #991b1b;
            margin-top: 5px;
        }

        /* 반응형 디자인 */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 20px;
            }
            
            .preset-grid,
            .group-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 8px;
                text-align: center;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
            }
            
            .section {
                padding: 15px;
            }

            .bulk-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .preset-grid,
            .group-grid {
                grid-template-columns: 1fr;
            }

            .client-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
        }

        /* 폼 스타일 */
        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 13px;
            font-family: inherit;
            transition: border-color 0.2s;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        textarea.form-input {
            resize: vertical;
            min-height: 60px;
        }

        .form-help {
            display: block;
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .radio-group {
            display: grid;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            transition: background-color 0.3s ease;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: background 0.2s;
            color: var(--text-primary);
            border: 1px solid transparent;
        }

        .radio-label:hover {
            background: var(--border-color);
        }

        .radio-label.selected {
            background: var(--info-bg);
            border-color: #3b82f6;
        }

        .radio-label input[type="radio"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* 클라이언트별 명령어 입력 스타일 */
        .client-command-section {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            transition: background-color 0.3s ease;
        }

        .client-command-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .client-command-item {
            margin-bottom: 15px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .client-command-item label {
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
            display: block;
        }

        .client-command-item .form-input {
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        /* 토스트 */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--text-secondary);
            color: white;
            padding: 12px 16px;
            border-radius: 6px;
            display: none;
            animation: slideIn 0.3s ease;
            box-shadow: 0 4px 12px var(--shadow-color);
            font-size: 12px;
            transition: background-color 0.3s ease;
            max-width: 300px;
            z-index: 1001;
        }

        .toast.success {
            background: #22c55e;
        }

        .toast.error {
            background: #ef4444;
        }

        .toast.warning {
            background: #f59e0b;
        }

        .toast.info {
            background: #3b82f6;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
            }
            to {
                transform: translateX(0);
            }
        }

        /* 상태 뱃지 */
        .status-badge {
            display: inline-block;
            padding: 2px 8px;
            font-size: 10px;
            font-weight: 600;
            border-radius: 12px;
            text-transform: uppercase;
        }

        .status-badge.online {
            background: var(--success-bg);
            color: #14532d;
        }

        .status-badge.offline {
            background: var(--error-bg);
            color: #991b1b;
        }

        .status-badge.running {
            background: var(--info-bg);
            color: #1e40af;
        }

        /* API 연결 상태 표시 */
        .api-status {
            position: fixed;
            top: 70px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 11px;
            box-shadow: 0 2px 8px var(--shadow-color);
            z-index: 999;
            display: none;
        }

        .api-status.visible {
            display: block;
        }

        .api-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }

        .api-indicator.connected {
            background: #22c55e;
        }

        .api-indicator.disconnected {
            background: #ef4444;
        }
    </style>
</head>
<body>
    <!-- API 연결 상태 표시 -->
    <div class="api-status" id="apiStatus">
        <span class="api-indicator disconnected" id="apiIndicator"></span>
        <span id="apiStatusText">API 연결 중...</span>
    </div>

    <!-- 헤더 -->
    <div class="header">
        <div class="header-content">
            <h1>⚡ Switchboard Plus v2.0</h1>
            <div class="status-info">
                <div class="socket-status">
                    🔌 Socket 상태: 
                    <span class="socket-indicator" id="socketIndicator"></span>
                    <span style="color: #22c55e; font-weight: 600;" id="socketStatus">연결 중...</span>
                </div>
                <div>🕒 시간: <span id="current-time">12:05:15</span></div>
                <div>📡 연결된 클라이언트: <span style="color: #22c55e; font-weight: 600;" id="connectedCount">0</span></div>
                <button class="settings-btn" onclick="toggleDarkMode()" id="themeToggle">🌙</button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- 통계 바 -->
        <div class="stats-bar">
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="totalClients">0</div>
                    <div class="stat-label">🖥️ 전체 디스플레이 서버</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="onlineClients">0</div>
                    <div class="stat-label">🟢 온라인</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="runningClients">0</div>
                    <div class="stat-label">⚡ 실행 중</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="activeExecutions">0</div>
                    <div class="stat-label">🎬 현재 실행 중</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalGroups">0</div>
                    <div class="stat-label">👥 그룹 수</div>
                </div>
            </div>
        </div>

        <!-- 메인 레이아웃 -->
        <div class="main-layout">
            <!-- 콘텐츠 프리셋 -->
            <div class="section">
                <h2 class="section-title">
                    📋 콘텐츠 프리셋
                    <button class="btn btn-secondary btn-with-text" onclick="showAddPresetModal()">
                        ➕ 새 프리셋
                    </button>
                </h2>
                
                <!-- 프리셋 일괄 제어 UI -->
                <div class="bulk-controls">
                    <div class="selection-info">
                        <label>
                            <input type="checkbox" id="selectAllPresets" onchange="toggleSelectAllPresets()">
                            전체 선택
                        </label>
                        <span>선택된 프리셋: <span id="selectedPresetCount">0</span>개</span>
                    </div>
                    <div class="bulk-actions">
                        <button class="btn btn-primary btn-bulk" onclick="bulkPresetAction('execute')" title="선택된 프리셋들 전체 실행">
                            ▶️
                        </button>
                        <button class="btn btn-danger btn-bulk" onclick="bulkPresetAction('stop')" title="선택된 프리셋들 전체 정지">
                            ⏹️
                        </button>
                        <button class="btn btn-danger btn-bulk" onclick="bulkPresetAction('delete')" title="선택된 프리셋들 전체 삭제">
                            🗑️
                        </button>
                    </div>
                </div>

                <div class="preset-grid" id="presetGrid">
                    <!-- 프리셋이 없을 때 표시 -->
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 16px;">📝</div>
                        <div style="font-size: 14px; margin-bottom: 8px;">아직 생성된 프리셋이 없습니다</div>
                        <div style="font-size: 12px;">새 프리셋 버튼을 클릭해서 첫 번째 프리셋을 만들어보세요!</div>
                    </div>
                </div>
            </div>

            <!-- 디스플레이 서버 그룹 -->
            <div class="section">
                <h2 class="section-title">
                    👥 디스플레이 서버 그룹
                    <button class="btn btn-secondary btn-with-text" onclick="showAddGroupModal()">
                        ➕ 새 그룹
                    </button>
                </h2>
                
                <!-- 그룹 일괄 제어 UI -->
                <div class="bulk-controls">
                    <div class="selection-info">
                        <label>
                            <input type="checkbox" id="selectAllGroups" onchange="toggleSelectAllGroups()">
                            전체 선택
                        </label>
                        <span>선택된 그룹: <span id="selectedGroupCount">0</span>개</span>
                    </div>
                    <div class="bulk-actions">
                        <button class="btn btn-primary btn-bulk" onclick="bulkGroupAction('on')" title="선택된 그룹들 전체 켜기">
                            🔌
                        </button>
                        <button class="btn btn-secondary btn-bulk" onclick="bulkGroupAction('reboot')" title="선택된 그룹들 전체 재부팅">
                            🔄
                        </button>
                        <button class="btn btn-danger btn-bulk" onclick="bulkGroupAction('off')" title="선택된 그룹들 전체 끄기">
                            ⚡
                        </button>
                    </div>
                </div>

                <div class="group-grid" id="groupGrid">
                    <!-- 그룹이 없을 때 표시 -->
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 16px;">👥</div>
                        <div style="font-size: 14px; margin-bottom: 8px;">아직 생성된 그룹이 없습니다</div>
                        <div style="font-size: 12px;">새 그룹 버튼을 클릭해서 첫 번째 그룹을 만들어보세요!</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 디스플레이 서버 모니터링 -->
        <div class="client-monitor">
            <div class="monitor-header">
                <h2 class="section-title">
                    🖥️ 디스플레이 서버 모니터링
                    <span style="font-size: 12px; color: var(--text-muted); font-weight: normal;">
                        자동 새로고침: <span id="refreshInterval">30초</span>
                    </span>
                </h2>
                <button class="btn btn-secondary btn-with-text" onclick="showAddClientModal()">
                    ➕ 클라이언트 추가
                </button>
            </div>

            <div class="client-grid" id="clientGrid">
                <!-- 클라이언트가 없을 때 표시 -->
                <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                    <div style="font-size: 48px; margin-bottom: 16px;">🖥️</div>
                    <div style="font-size: 14px; margin-bottom: 8px;">연결된 디스플레이 서버가 없습니다</div>
                    <div style="font-size: 12px;">클라이언트 추가 버튼을 클릭하거나 Python 클라이언트가 연결되면 자동으로 나타납니다</div>
                </div>
            </div>
        </div>


    </div>

    <!-- 클라이언트 추가 모달 -->
    <div class="modal" id="addClientModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>🖥️ 새 디스플레이 서버 추가</h3>
                <span class="close" onclick="closeAddClientModal()">&times;</span>
            </div>
            
            <div class="modal-body">
                <form id="addClientForm">
                    <div class="form-group">
                        <label for="clientName">🏷️ 클라이언트 이름</label>
                        <input type="text" id="clientName" class="form-input" placeholder="예: Display_01" required>
                        <small class="form-help">알아보기 쉬운 이름을 지정하세요 (중복 불가)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="clientIP">🌐 IP 주소</label>
                        <input type="text" id="clientIP" class="form-input" placeholder="192.168.1.101" pattern="^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$" required>
                        <small class="form-help">클라이언트 PC의 고정 IP 주소</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="clientPort">🔌 포트</label>
                        <input type="number" id="clientPort" class="form-input" placeholder="8081" value="8081" min="1" max="65535">
                        <small class="form-help">Python 클라이언트 통신 포트 (기본: 8081)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="clientDescription">📝 설명 (선택)</label>
                        <textarea id="clientDescription" class="form-input" rows="2" placeholder="이 클라이언트에 대한 메모 (위치, 용도 등)"></textarea>
                    </div>
                    
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="closeAddClientModal()">취소</button>
                        <button type="submit" class="btn btn-primary">추가</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- 클라이언트 상세 모달 -->
    <div class="modal" id="clientModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalClientName">클라이언트 관리</h3>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            
            <div class="modal-body">
                <!-- 시스템 정보 -->
                <div class="info-section">
                    <h4>📋 시스템 정보</h4>
                    <div class="info-grid">
                        <div>🏷️ 이름: <strong id="modalClientNameText">-</strong></div>
                        <div>🌐 IP 주소: <strong id="modalClientIP">-</strong></div>
                        <div>🔌 포트: <strong id="modalClientPort">-</strong></div>
                        <div>📊 상태: <span id="modalClientStatus" class="status-badge offline">오프라인</span></div>
                        <div>🕒 마지막 연결: <span id="modalLastSeen">-</span></div>
                        <div>🆔 현재 실행 ID: <span id="modalExecutionId">없음</span></div>
                    </div>
                </div>
                
                <!-- 성능 메트릭 (실행 중일 때만 표시) -->
                <div class="info-section" id="metricsSection" style="display: none;">
                    <h4>⚡ 성능 모니터링</h4>
                    <div class="info-grid">
                        <div>🖥️ CPU 사용률: <span id="modalCPU">0%</span></div>
                        <div>💾 메모리 사용률: <span id="modalRAM">0%</span></div>
                        <div>💿 디스크 사용률: <span id="modalDisk">0%</span></div>
                        <div>📡 네트워크 지연: <span id="modalLatency">0ms</span></div>
                        <div>🎮 언리얼엔진 프로세스: <span id="modalProcessCount">0개</span></div>
                    </div>
                </div>
                
                <!-- 전원 제어 (v2.1 기능) -->
                <div class="info-section">
                    <h4>⚡ 전원 제어 <span style="font-size: 11px; color: var(--text-muted);">(v2.1)</span></h4>
                    <div class="button-group">
                        <button class="btn btn-primary btn-with-text" onclick="powerAction('on')" title="Wake-on-LAN으로 전원 켜기" disabled>
                            🔌 전원 켜기
                        </button>
                        <button class="btn btn-secondary btn-with-text" onclick="powerAction('reboot')" title="원격 재부팅" disabled>
                            🔄 재부팅
                        </button>
                        <button class="btn btn-danger btn-with-text" onclick="powerAction('off')" title="원격 종료" disabled>
                            ⚡ 전원 끄기
                        </button>
                    </div>
                    <p class="warning-text">💡 전원 제어 기능은 v2.1에서 활성화됩니다.</p>
                </div>
                
                <!-- 위험 구역 -->
                <div class="danger-section">
                    <h4>⚠️ 위험 구역</h4>
                    <button class="btn btn-danger btn-with-text" onclick="deleteClient()" title="데이터베이스에서 완전 삭제">
                        🗑️ 클라이언트 삭제
                    </button>
                    <p class="warning-text">⚠️ 삭제하면 데이터베이스에서 완전히 제거되며 복구할 수 없습니다.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- 🆕 개선된 프리셋 추가/편집 모달 -->
    <div class="modal" id="presetModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="presetModalTitle">새 프리셋 만들기</h3>
                <span class="close" onclick="closePresetModal()">&times;</span>
            </div>
            
            <div class="modal-body">
                <form id="presetForm">
                    <!-- 1단계: 기본 정보 -->
                    <div class="form-group">
                        <label for="presetName">📋 프리셋 이름</label>
                        <input type="text" id="presetName" class="form-input" placeholder="예: 메인 콘텐츠" required>
                        <small class="form-help">알아보기 쉬운 프리셋 이름</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="presetDescription">📝 설명 (선택)</label>
                        <textarea id="presetDescription" class="form-input" rows="2" placeholder="프리셋에 대한 설명을 입력하세요"></textarea>
                    </div>
                    
                    <!-- 2단계: 대상 그룹 선택 (라디오 버튼) -->
                    <div class="form-group">
                        <label>🎯 대상 그룹 선택 (필수)</label>
                        <div class="radio-group" id="presetGroupList">
                            <!-- 그룹 목록이 라디오 버튼으로 동적 추가됩니다 -->
                            <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                                먼저 그룹을 생성해주세요
                            </div>
                        </div>
                        <small class="form-help">📌 그룹을 선택하면 해당 클라이언트별로 명령어를 설정할 수 있습니다</small>
                    </div>
                    
                    <!-- 3단계: 선택된 그룹의 클라이언트별 명령어 설정 -->
                    <div class="client-command-section" id="clientCommandSection" style="display: none;">
                        <div class="client-command-header">
                            <h4>🖥️ 클라이언트별 언리얼엔진 실행 명령어</h4>
                            <span id="selectedGroupName" style="color: var(--text-muted); font-size: 12px;"></span>
                        </div>
                        <div id="clientCommandsList">
                            <!-- 선택된 그룹의 클라이언트별 명령어 입력창이 동적으로 추가됩니다 -->
                        </div>
                        <small class="form-help">
                            💡 <strong>팁:</strong> 각 클라이언트별로 다른 nDisplay 노드를 설정하세요<br>
                            예시: <code>D:\UnrealProjects\MyProject\Windows\MyProject.exe -dc_node=Node_0 -fullscreen</code>
                        </small>
                    </div>
                    
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="closePresetModal()">취소</button>
                        <button type="submit" class="btn btn-primary">저장</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- 그룹 추가/편집 모달 -->
    <div class="modal" id="groupModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="groupModalTitle">새 그룹 만들기</h3>
                <span class="close" onclick="closeGroupModal()">&times;</span>
            </div>
            
            <div class="modal-body">
                <form id="groupForm">
                    <div class="form-group">
                        <label for="groupName">👥 그룹 이름</label>
                        <input type="text" id="groupName" class="form-input" placeholder="예: 메인 디스플레이 월" required>
                        <small class="form-help">알아보기 쉬운 그룹 이름</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="groupDescription">📝 설명 (선택)</label>
                        <textarea id="groupDescription" class="form-input" rows="2" placeholder="그룹에 대한 설명을 입력하세요 (위치, 용도 등)"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label>🖥️ 포함할 디스플레이 서버</label>
                        <div class="radio-group" id="groupClientList">
                            <!-- 클라이언트 목록이 동적으로 추가됩니다 -->
                            <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                                먼저 클라이언트를 추가해주세요
                            </div>
                        </div>
                        <small class="form-help">그룹에 포함할 디스플레이 서버를 선택하세요. 한 클라이언트는 여러 그룹에 포함될 수 있습니다.</small>
                    </div>
                    
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="closeGroupModal()">취소</button>
                        <button type="submit" class="btn btn-primary">저장</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- 토스트 알림 -->
    <div class="toast" id="toast"></div>

    <script>
        // ==================== 전역 상태 관리 ====================
        let isDarkMode = false;
        let isSocketConnected = false;
        let isApiConnected = false;
        let selectedGroups = new Set();
        let selectedPresets = new Set();
        let currentClientId = null;
        let editingPresetId = null;
        let editingGroupId = null;
        let autoRefreshTimer = null;
        let selectedPresetGroupId = null; // 🆕 선택된 그룹 ID 저장

        // 데이터 저장소 (실제 구현에서는 서버에서 관리)
        let clients = new Map();
        let groups = new Map();
        let presets = new Map();
        let executions = new Map();

        // ==================== 초기화 ====================
        window.onload = function() {
            initializeTheme();
            initializeAPI();
            initializeSocket();
            startAutoRefresh();
            updateTime();
            setInterval(updateTime, 1000);
            updateAllStats();
        };

        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                toggleDarkMode();
            }
        }

        function initializeAPI() {
            // API 연결 상태 시뮬레이션
            showApiStatus('connecting');
            
            setTimeout(() => {
                isApiConnected = Math.random() > 0.2;
                showApiStatus(isApiConnected ? 'connected' : 'failed');
                
                if (isApiConnected) {
                    loadInitialData();
                }
            }, 2000);

            setInterval(() => {
                checkApiConnection();
            }, 30000);
        }

        function initializeSocket() {
            setTimeout(() => {
                isSocketConnected = Math.random() > 0.1;
                updateSocketStatus();
                
                if (isSocketConnected) {
                    simulateRealTimeUpdates();
                }
            }, 1500);
        }

        function loadInitialData() {
            showToast('📊 초기 데이터를 로드했습니다.', 'success');
        }

        // ==================== 시간 및 자동 새로고침 ====================
        function updateTime() {
            const now = new Date();
            document.getElementById('current-time').textContent = 
                now.toLocaleTimeString('ko-KR', {hour12: true, hour: '2-digit', minute: '2-digit', second: '2-digit'});
        }

        function startAutoRefresh() {
            autoRefreshTimer = setInterval(() => {
                if (isApiConnected) {
                    refreshClientsData();
                }
            }, 30000);
        }

        function refreshClientsData() {
            console.log('클라이언트 데이터 자동 새로고침...');
            
            document.querySelectorAll('.client-item').forEach(item => {
                if (Math.random() < 0.1) {
                    simulateClientStatusChange(item);
                }
            });
        }

        // ==================== API 및 Socket 상태 관리 ====================
        function showApiStatus(status) {
            const apiStatus = document.getElementById('apiStatus');
            const indicator = document.getElementById('apiIndicator');
            const statusText = document.getElementById('apiStatusText');
            
            apiStatus.classList.add('visible');
            
            switch(status) {
                case 'connecting':
                    indicator.className = 'api-indicator disconnected';
                    statusText.textContent = 'API 연결 중...';
                    break;
                case 'connected':
                    indicator.className = 'api-indicator connected';
                    statusText.textContent = 'API 연결됨';
                    setTimeout(() => apiStatus.classList.remove('visible'), 3000);
                    break;
                case 'failed':
                    indicator.className = 'api-indicator disconnected';
                    statusText.textContent = 'API 연결 실패';
                    break;
            }
        }

        function checkApiConnection() {
            const wasConnected = isApiConnected;
            isApiConnected = Math.random() > 0.15;
            
            if (wasConnected !== isApiConnected) {
                showApiStatus(isApiConnected ? 'connected' : 'failed');
                if (!isApiConnected) {
                    showToast('API 연결이 끊어졌습니다. 재연결 시도 중...', 'error');
                }
            }
        }

        function updateSocketStatus() {
            const indicator = document.getElementById('socketIndicator');
            const status = document.getElementById('socketStatus');
            
            if (isSocketConnected) {
                indicator.classList.remove('disconnected');
                status.textContent = '연결됨';
                status.style.color = '#22c55e';
            } else {
                indicator.classList.add('disconnected');
                status.textContent = '연결 끊김';
                status.style.color = '#ef4444';
            }
        }

        // ==================== 실시간 업데이트 시뮬레이션 ====================
        function simulateRealTimeUpdates() {
            setInterval(() => {
                if (isSocketConnected && clients.size > 0) {
                    simulateRandomClientUpdate();
                }
            }, 15000);
        }

        function simulateRandomClientUpdate() {
            const clientElements = document.querySelectorAll('.client-item');
            if (clientElements.length > 0) {
                const randomClient = clientElements[Math.floor(Math.random() * clientElements.length)];
                simulateClientStatusChange(randomClient);
            }
        }

        function simulateClientStatusChange(clientElement) {
            const clientId = clientElement.getAttribute('data-client-id');
            const currentStatus = clientElement.classList.contains('running') ? 'running' : 
                                 clientElement.classList.contains('online') ? 'online' : 'offline';
            
            let newStatus = currentStatus;
            
            if (currentStatus === 'offline' && Math.random() < 0.3) {
                newStatus = 'online';
            } else if (currentStatus === 'online' && Math.random() < 0.2) {
                newStatus = Math.random() < 0.5 ? 'running' : 'offline';
            } else if (currentStatus === 'running' && Math.random() < 0.1) {
                newStatus = 'online';
            }
            
            if (newStatus !== currentStatus) {
                updateClientStatus(clientId, newStatus);
            }
        }

        function updateClientStatus(clientId, status) {
            const clientElement = document.querySelector(`[data-client-id="${clientId}"]`);
            if (!clientElement) return;
            
            clientElement.className = `client-item ${status}`;
            
            const icon = clientElement.querySelector('.client-icon');
            const statusText = clientElement.querySelector('.client-status');
            const metricsDiv = clientElement.querySelector('.client-metrics');
            
            switch(status) {
                case 'online':
                    icon.textContent = '🟡';
                    statusText.textContent = '대기 중';
                    if (metricsDiv) metricsDiv.style.display = 'none';
                    break;
                case 'running':
                    icon.textContent = '🟢';
                    statusText.textContent = '실행 중';
                    if (metricsDiv) {
                        metricsDiv.style.display = 'block';
                        updateClientMetrics(clientId);
                    }
                    break;
                case 'offline':
                    icon.textContent = '🔴';
                    statusText.textContent = '오프라인';
                    if (metricsDiv) metricsDiv.style.display = 'none';
                    break;
            }
            
            if (clients.has(clientId)) {
                const client = clients.get(clientId);
                client.status = status;
                client.last_seen = new Date();
                clients.set(clientId, client);
            }
            
            updateAllStats();
        }

        function updateClientMetrics(clientId) {
            const metricsDiv = document.querySelector(`[data-client-id="${clientId}"] .client-metrics`);
            if (metricsDiv) {
                const cpu = Math.floor(Math.random() * 100);
                const ram = Math.floor(Math.random() * 100);
                const latency = Math.floor(Math.random() * 50) + 10;
                
                metricsDiv.innerHTML = `
                    CPU: ${cpu}%<br>
                    RAM: ${ram}%<br>
                    지연: ${latency}ms
                `;
            }
        }

        // ==================== 테마 관리 ====================
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            const body = document.body;
            const themeToggle = document.getElementById('themeToggle');
            
            if (isDarkMode) {
                body.setAttribute('data-theme', 'dark');
                themeToggle.textContent = '☀️';
                localStorage.setItem('theme', 'dark');
                showToast('🌙 다크 모드가 활성화되었습니다.', 'success');
            } else {
                body.removeAttribute('data-theme');
                themeToggle.textContent = '🌙';
                localStorage.setItem('theme', 'light');
                showToast('☀️ 라이트 모드가 활성화되었습니다.', 'success');
            }
        }

        // ==================== 통계 업데이트 ====================
        function updateAllStats() {
            const runningClients = document.querySelectorAll('.client-item.running').length;
            const onlineClients = document.querySelectorAll('.client-item.online, .client-item.running').length;
            const totalClients = document.querySelectorAll('.client-item').length;
            const totalGroups = document.querySelectorAll('.group-card').length;
            const activeExecutionsCount = Array.from(executions.values()).filter(exec => exec.status === 'running').length;
            
            document.getElementById('totalClients').textContent = totalClients;
            document.getElementById('runningClients').textContent = runningClients;
            document.getElementById('onlineClients').textContent = onlineClients;
            document.getElementById('activeExecutions').textContent = activeExecutionsCount;
            document.getElementById('totalGroups').textContent = totalGroups;
            document.getElementById('connectedCount').textContent = onlineClients;
            
            updateEmptyStates();
        }

        function updateEmptyStates() {
            const presetGrid = document.getElementById('presetGrid');
            const groupGrid = document.getElementById('groupGrid');
            const clientGrid = document.getElementById('clientGrid');
            
            // 프리셋 빈 상태
            const presetCards = presetGrid.querySelectorAll('.preset-card');
            const presetEmpty = presetGrid.querySelector('[style*="grid-column"]');
            if (presetCards.length === 0 && !presetEmpty) {
                presetGrid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 16px;">📝</div>
                        <div style="font-size: 14px; margin-bottom: 8px;">아직 생성된 프리셋이 없습니다</div>
                        <div style="font-size: 12px;">새 프리셋 버튼을 클릭해서 첫 번째 프리셋을 만들어보세요!</div>
                    </div>
                `;
            } else if (presetCards.length > 0 && presetEmpty) {
                presetEmpty.remove();
            }
            
            // 그룹 빈 상태
            const groupCards = groupGrid.querySelectorAll('.group-card');
            const groupEmpty = groupGrid.querySelector('[style*="grid-column"]');
            if (groupCards.length === 0 && !groupEmpty) {
                groupGrid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 16px;">👥</div>
                        <div style="font-size: 14px; margin-bottom: 8px;">아직 생성된 그룹이 없습니다</div>
                        <div style="font-size: 12px;">새 그룹 버튼을 클릭해서 첫 번째 그룹을 만들어보세요!</div>
                    </div>
                `;
            } else if (groupCards.length > 0 && groupEmpty) {
                groupEmpty.remove();
            }
            
            // 클라이언트 빈 상태
            const clientItems = clientGrid.querySelectorAll('.client-item');
            const clientEmpty = clientGrid.querySelector('[style*="grid-column"]');
            if (clientItems.length === 0 && !clientEmpty) {
                clientGrid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 16px;">🖥️</div>
                        <div style="font-size: 14px; margin-bottom: 8px;">연결된 디스플레이 서버가 없습니다</div>
                        <div style="font-size: 12px;">클라이언트 추가 버튼을 클릭하거나 Python 클라이언트가 연결되면 자동으로 나타납니다</div>
                    </div>
                `;
            } else if (clientItems.length > 0 && clientEmpty) {
                clientEmpty.remove();
            }
        }

        // ==================== 클라이언트 관리 ====================
        function showAddClientModal() {
            document.getElementById('addClientModal').style.display = 'flex';
            document.getElementById('addClientForm').reset();
        }

        function closeAddClientModal() {
            document.getElementById('addClientModal').style.display = 'none';
        }

        document.getElementById('addClientForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const name = document.getElementById('clientName').value.trim();
            const ip = document.getElementById('clientIP').value.trim();
            const port = parseInt(document.getElementById('clientPort').value) || 8081;
            const description = document.getElementById('clientDescription').value.trim();
            
            const existingNames = Array.from(clients.values()).map(c => c.name);
            const existingIPs = Array.from(clients.values()).map(c => c.ip_address);
            
            if (existingNames.includes(name)) {
                showToast('이미 존재하는 클라이언트 이름입니다.', 'error');
                return;
            }
            
            if (existingIPs.includes(ip)) {
                showToast('이미 등록된 IP 주소입니다.', 'error');
                return;
            }
            
            const clientId = `client_${Date.now()}`;
            const newClient = {
                id: clientId,
                name: name,
                ip_address: ip,
                port: port,
                description: description,
                status: 'offline',
                created_at: new Date(),
                last_seen: null
            };
            
            clients.set(clientId, newClient);
            addClientToDOM(newClient);
            
            setTimeout(() => {
                verifyClientConnection(clientId);
            }, 2000);
            
            updateGroupClientList();
            updateAllStats();
            closeAddClientModal();
            
            showToast(`클라이언트 "${name}"이(가) 추가되었습니다. 연결을 확인하고 있습니다...`, 'success');
        });

        function addClientToDOM(client) {
            const clientGrid = document.getElementById('clientGrid');
            
            const emptyMessage = clientGrid.querySelector('[style*="grid-column"]');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            const clientElement = document.createElement('div');
            clientElement.className = 'client-item offline';
            clientElement.setAttribute('data-client-id', client.id);
            clientElement.onclick = () => showClientModal(client.id);
            
            clientElement.innerHTML = `
                <div class="client-icon">🔴</div>
                <div class="client-name">${client.name}</div>
                <div class="client-ip">${client.ip_address}</div>
                <div class="client-status">오프라인</div>
                <div class="client-metrics" style="display: none;">
                    CPU: 0%<br>RAM: 0%<br>지연: 0ms
                </div>
            `;
            
            clientGrid.appendChild(clientElement);
        }

        function verifyClientConnection(clientId) {
            const success = Math.random() > 0.3;
            
            if (success) {
                updateClientStatus(clientId, 'online');
                const client = clients.get(clientId);
                showToast(`클라이언트 "${client.name}"이(가) 연결되었습니다!`, 'success');
            } else {
                const client = clients.get(clientId);
                showToast(`클라이언트 "${client.name}"이(가) 응답하지 않습니다. 네트워크를 확인해주세요.`, 'warning');
            }
        }

        function showClientModal(clientId) {
            currentClientId = clientId;
            const client = clients.get(clientId);
            
            if (!client) return;
            
            document.getElementById('modalClientName').textContent = `🖥️ ${client.name} 관리`;
            document.getElementById('modalClientNameText').textContent = client.name;
            document.getElementById('modalClientIP').textContent = client.ip_address;
            document.getElementById('modalClientPort').textContent = client.port;
            document.getElementById('modalLastSeen').textContent = client.last_seen ? 
                formatRelativeTime(client.last_seen) : '연결된 적 없음';
            
            const statusBadge = document.getElementById('modalClientStatus');
            statusBadge.className = `status-badge ${client.status}`;
            statusBadge.textContent = getStatusText(client.status);
            
            const executionIdElement = document.getElementById('modalExecutionId');
            if (client.status === 'running') {
                executionIdElement.textContent = `exec_${clientId}_${Date.now().toString().slice(-6)}`;
            } else {
                executionIdElement.textContent = '없음';
            }
            
            const metricsSection = document.getElementById('metricsSection');
            
            if (client.status === 'running') {
                metricsSection.style.display = 'block';
                
                document.getElementById('modalCPU').textContent = Math.floor(Math.random() * 100) + '%';
                document.getElementById('modalRAM').textContent = Math.floor(Math.random() * 100) + '%';
                document.getElementById('modalDisk').textContent = Math.floor(Math.random() * 100) + '%';
                document.getElementById('modalLatency').textContent = Math.floor(Math.random() * 50) + 10 + 'ms';
                document.getElementById('modalProcessCount').textContent = Math.floor(Math.random() * 3) + 1 + '개';
            } else {
                metricsSection.style.display = 'none';
            }
            
            document.getElementById('clientModal').style.display = 'flex';
        }

        function formatRelativeTime(date) {
            const now = new Date();
            const diff = now - date;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (minutes < 1) return '방금 전';
            if (minutes < 60) return `${minutes}분 전`;
            if (hours < 24) return `${hours}시간 전`;
            return `${days}일 전`;
        }

        function getStatusText(status) {
            const statusTexts = {
                'online': '온라인',
                'running': '실행 중',
                'offline': '오프라인'
            };
            return statusTexts[status] || status;
        }

        function closeModal() {
            document.getElementById('clientModal').style.display = 'none';
            currentClientId = null;
        }

        function clientAction(action) {
            const client = clients.get(currentClientId);
            if (!client) return;
            
            switch(action) {
                case 'heartbeat':
                    showToast(`"${client.name}"에 상태 확인 요청을 전송했습니다.`, 'info');
                    break;
                case 'stop_all':
                    if (client.status === 'running') {
                        updateClientStatus(currentClientId, 'online');
                        showToast(`"${client.name}"의 모든 프로세스 중지 명령을 전송했습니다.`, 'success');
                        addClientHistory(currentClientId, '모든 프로세스 중지됨');
                    } else {
                        showToast('실행 중인 프로세스가 없습니다.', 'warning');
                    }
                    break;
            }
        }

        function powerAction(action) {
            const actionNames = {
                'on': '켜기',
                'reboot': '재부팅',
                'off': '끄기'
            };
            showToast(`전원 ${actionNames[action]} 기능은 v2.1에서 활성화됩니다.`, 'info');
        }

        function deleteClient() {
            const client = clients.get(currentClientId);
            if (!client) return;
            
            if (confirm(`정말 "${client.name}" 클라이언트를 삭제하시겠습니까?\n실행 중인 프로세스는 자동으로 중지됩니다.`)) {
                const clientElement = document.querySelector(`[data-client-id="${currentClientId}"]`);
                if (clientElement) {
                    clientElement.remove();
                }
                
                clients.delete(currentClientId);
                clientHistory.delete(currentClientId);
                
                selectedGroups.delete(currentClientId);
                
                updateGroupClientList();
                updateAllStats();
                closeModal();
                
                showToast(`클라이언트 "${client.name}"이(가) 삭제되었습니다.`, 'error');
            }
        }

        // ==================== 그룹 관리 ====================
        function showAddGroupModal() {
            editingGroupId = null;
            document.getElementById('groupModalTitle').textContent = '👥 새 그룹 만들기';
            document.getElementById('groupForm').reset();
            updateGroupClientList();
            document.getElementById('groupModal').style.display = 'flex';
        }

        function editGroup(groupId) {
            editingGroupId = groupId;
            document.getElementById('groupModalTitle').textContent = '👥 그룹 편집';
            
            const group = groups.get(groupId);
            if (group) {
                document.getElementById('groupName').value = group.name;
                document.getElementById('groupDescription').value = group.description || '';
                
                updateGroupClientList();
                
                group.client_ids.forEach(clientId => {
                    const checkbox = document.querySelector(`input[name="groupClients"][value="${clientId}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }
            
            document.getElementById('groupModal').style.display = 'flex';
        }

        function closeGroupModal() {
            document.getElementById('groupModal').style.display = 'none';
            document.getElementById('groupForm').reset();
            editingGroupId = null;
        }

        function updateGroupClientList() {
            const clientList = document.getElementById('groupClientList');
            
            if (clients.size === 0) {
                clientList.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                        🖥️ 먼저 클라이언트를 추가해주세요
                    </div>
                `;
                return;
            }
            
            clientList.innerHTML = '';
            clients.forEach((client, clientId) => {
                const label = document.createElement('label');
                label.className = 'radio-label';
                label.innerHTML = `
                    <input type="checkbox" name="groupClients" value="${clientId}">
                    <span>${client.name} (${client.ip_address})</span>
                `;
                clientList.appendChild(label);
            });
        }

        document.getElementById('groupForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const name = document.getElementById('groupName').value.trim();
            const description = document.getElementById('groupDescription').value.trim();
            const selectedClients = Array.from(document.querySelectorAll('input[name="groupClients"]:checked'))
                .map(cb => cb.value);
            
            if (selectedClients.length === 0) {
                showToast('최소 하나 이상의 디스플레이 서버를 선택해주세요.', 'error');
                return;
            }
            
            const existingNames = Array.from(groups.values()).map(g => g.name);
            if (!editingGroupId && existingNames.includes(name)) {
                showToast('이미 존재하는 그룹 이름입니다.', 'error');
                return;
            }
            
            if (editingGroupId) {
                const group = groups.get(editingGroupId);
                group.name = name;
                group.description = description;
                group.client_ids = selectedClients;
                groups.set(editingGroupId, group);
                
                updateGroupInDOM(group);
                showToast(`그룹 "${name}"이(가) 수정되었습니다.`, 'success');
            } else {
                const groupId = `group_${Date.now()}`;
                const newGroup = {
                    id: groupId,
                    name: name,
                    description: description,
                    client_ids: selectedClients,
                    created_at: new Date()
                };
                
                groups.set(groupId, newGroup);
                addGroupToDOM(newGroup);
                showToast(`새 그룹 "${name}"이(가) 생성되었습니다.`, 'success');
            }
            
            updatePresetGroupList();
            updateAllStats();
            closeGroupModal();
        });

        function addGroupToDOM(group) {
            const groupGrid = document.getElementById('groupGrid');
            
            const emptyMessage = groupGrid.querySelector('[style*="grid-column"]');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            const groupElement = document.createElement('div');
            groupElement.className = 'group-card';
            groupElement.innerHTML = createGroupCardHTML(group);
            
            groupGrid.appendChild(groupElement);
        }

        function updateGroupInDOM(group) {
            const groupCard = document.querySelector(`[data-group-id="${group.id}"]`).closest('.group-card');
            if (groupCard) {
                groupCard.innerHTML = createGroupCardHTML(group);
            }
        }

        function createGroupCardHTML(group) {
            const clientTags = group.client_ids.map(clientId => {
                const client = clients.get(clientId);
                return client ? `<span class="client-tag">${client.ip_address}</span>` : '';
            }).join('');
            
            return `
                <input type="checkbox" class="group-checkbox" data-group-id="${group.id}" onclick="event.stopPropagation()" onchange="updateSelectedGroupCount()">
                <div class="group-content">
                    <div class="group-name">${group.name}</div>
                    <div class="group-info">${group.client_ids.length}개 디스플레이 서버</div>
                    <div class="group-clients">
                        ${clientTags}
                    </div>
                </div>
                <div class="group-actions">
                    <button class="btn btn-secondary" onclick="editGroup('${group.id}')" title="편집">✏️</button>
                    <button class="btn btn-danger" onclick="deleteGroup('${group.id}')" title="삭제">🗑️</button>
                </div>
            `;
        }

        function deleteGroup(groupId) {
            const group = groups.get(groupId);
            if (!group) return;
            
            if (confirm(`정말 "${group.name}" 그룹을 삭제하시겠습니까?\n그룹만 삭제되고 클라이언트는 유지됩니다.`)) {
                const groupCard = document.querySelector(`[data-group-id="${groupId}"]`).closest('.group-card');
                if (groupCard) {
                    groupCard.remove();
                }
                
                groups.delete(groupId);
                
                selectedGroups.delete(groupId);
                updateSelectedGroupCount();
                
                updatePresetGroupList();
                updateAllStats();
                
                showToast(`그룹 "${group.name}"이(가) 삭제되었습니다.`, 'error');
            }
        }

        // ==================== 🆕 개선된 프리셋 관리 ====================
        function showAddPresetModal() {
            editingPresetId = null;
            selectedPresetGroupId = null; // 🆕 선택된 그룹 초기화
            document.getElementById('presetModalTitle').textContent = '📋 새 프리셋 만들기';
            document.getElementById('presetForm').reset();
            document.getElementById('clientCommandSection').style.display = 'none'; // 🆕 명령어 섹션 숨김
            updatePresetGroupList();
            document.getElementById('presetModal').style.display = 'flex';
        }

        function editPreset(presetId) {
            editingPresetId = presetId;
            document.getElementById('presetModalTitle').textContent = '📋 프리셋 편집';
            
            const preset = presets.get(presetId);
            if (preset) {
                document.getElementById('presetName').value = preset.name;
                document.getElementById('presetDescription').value = preset.description || '';
                
                updatePresetGroupList();
                
                // 🆕 선택된 그룹 설정 및 명령어 로드
                if (preset.group_id) {
                    selectedPresetGroupId = preset.group_id;
                    const radio = document.querySelector(`input[name="presetGroup"][value="${preset.group_id}"]`);
                    if (radio) {
                        radio.checked = true;
                        radio.parentElement.classList.add('selected');
                        onPresetGroupSelected(preset.group_id);
                        
                        // 기존 명령어들 로드
                        if (preset.client_commands) {
                            Object.entries(preset.client_commands).forEach(([clientId, command]) => {
                                const input = document.querySelector(`input[data-client-id="${clientId}"]`);
                                if (input) {
                                    input.value = command;
                                }
                            });
                        }
                    }
                }
            }
            
            document.getElementById('presetModal').style.display = 'flex';
        }

        function closePresetModal() {
            document.getElementById('presetModal').style.display = 'none';
            document.getElementById('presetForm').reset();
            document.getElementById('clientCommandSection').style.display = 'none';
            selectedPresetGroupId = null;
            editingPresetId = null;
        }

        // 🆕 프리셋 그룹 목록 업데이트 (라디오 버튼으로 변경)
        function updatePresetGroupList() {
            const groupList = document.getElementById('presetGroupList');
            
            if (groups.size === 0) {
                groupList.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                        👥 먼저 그룹을 생성해주세요
                    </div>
                `;
                return;
            }
            
            groupList.innerHTML = '';
            groups.forEach((group, groupId) => {
                const label = document.createElement('label');
                label.className = 'radio-label';
                label.innerHTML = `
                    <input type="radio" name="presetGroup" value="${groupId}" onchange="onPresetGroupSelected('${groupId}')">
                    <span>
                        <strong>${group.name}</strong><br>
                        <small style="color: var(--text-muted);">${group.client_ids.length}개 클라이언트: ${group.client_ids.map(id => clients.get(id)?.name || 'Unknown').join(', ')}</small>
                    </span>
                `;
                groupList.appendChild(label);
            });
        }

        // 🆕 그룹 선택 시 호출되는 함수
        function onPresetGroupSelected(groupId) {
            selectedPresetGroupId = groupId;
            const group = groups.get(groupId);
            
            if (!group) return;
            
            // 기존 선택된 라디오 버튼 스타일 제거
            document.querySelectorAll('.radio-label').forEach(label => {
                label.classList.remove('selected');
            });
            
            // 새로 선택된 라디오 버튼 스타일 추가
            const selectedRadio = document.querySelector(`input[name="presetGroup"][value="${groupId}"]`);
            if (selectedRadio) {
                selectedRadio.parentElement.classList.add('selected');
            }
            
            // 클라이언트별 명령어 섹션 표시
            showClientCommandSection(group);
        }

        // 🆕 클라이언트별 명령어 섹션 표시
        function showClientCommandSection(group) {
            const section = document.getElementById('clientCommandSection');
            const groupNameSpan = document.getElementById('selectedGroupName');
            const commandsList = document.getElementById('clientCommandsList');
            
            groupNameSpan.textContent = `선택된 그룹: ${group.name}`;
            section.style.display = 'block';
            
            // 클라이언트별 명령어 입력창 생성
            commandsList.innerHTML = '';
            
            group.client_ids.forEach(clientId => {
                const client = clients.get(clientId);
                if (!client) return;
                
                const commandItem = document.createElement('div');
                commandItem.className = 'client-command-item';
                
                commandItem.innerHTML = `
                    <label for="command_${clientId}">
                        🖥️ ${client.name} (${client.ip_address})
                    </label>
                    <input 
                        type="text" 
                        id="command_${clientId}" 
                        data-client-id="${clientId}"
                        class="form-input" 
                        placeholder="예: D:\\UnrealProjects\\MyProject\\Windows\\MyProject.exe -dc_node=Node_${group.client_ids.indexOf(clientId)} -fullscreen"
                        required
                    >
                    <small style="color: var(--text-muted); font-size: 10px; display: block; margin-top: 4px;">
                        💡 이 클라이언트에서 실행될 완전한 명령어를 입력하세요
                    </small>
                `;
                
                commandsList.appendChild(commandItem);
            });
            
            // 스크롤을 명령어 섹션으로 이동
            section.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // 🆕 프리셋 폼 제출 처리 (개선됨)
        document.getElementById('presetForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const name = document.getElementById('presetName').value.trim();
            const description = document.getElementById('presetDescription').value.trim();
            
            // 🆕 그룹 선택 확인
            if (!selectedPresetGroupId) {
                showToast('대상 그룹을 선택해주세요.', 'error');
                return;
            }
            
            // 🆕 클라이언트별 명령어 수집
            const clientCommands = {};
            const group = groups.get(selectedPresetGroupId);
            let hasEmptyCommand = false;
            
            group.client_ids.forEach(clientId => {
                const input = document.querySelector(`input[data-client-id="${clientId}"]`);
                if (input) {
                    const command = input.value.trim();
                    if (!command) {
                        hasEmptyCommand = true;
                        return;
                    }
                    clientCommands[clientId] = command;
                }
            });
            
            if (hasEmptyCommand) {
                showToast('모든 클라이언트의 명령어를 입력해주세요.', 'error');
                return;
            }
            
            // 중복 이름 체크
            const existingNames = Array.from(presets.values()).map(p => p.name);
            if (!editingPresetId && existingNames.includes(name)) {
                showToast('이미 존재하는 프리셋 이름입니다.', 'error');
                return;
            }
            
            if (editingPresetId) {
                // 프리셋 수정
                const preset = presets.get(editingPresetId);
                preset.name = name;
                preset.description = description;
                preset.group_id = selectedPresetGroupId; // 🆕 단일 그룹 ID
                preset.client_commands = clientCommands; // 🆕 클라이언트별 명령어
                presets.set(editingPresetId, preset);
                
                updatePresetInDOM(preset);
                showToast(`프리셋 "${name}"이(가) 수정되었습니다.`, 'success');
            } else {
                // 새 프리셋 생성
                const presetId = `preset_${Date.now()}`;
                const newPreset = {
                    id: presetId,
                    name: name,
                    description: description,
                    group_id: selectedPresetGroupId, // 🆕 단일 그룹 ID
                    client_commands: clientCommands, // 🆕 클라이언트별 명령어
                    created_at: new Date(),
                    is_active: false
                };
                
                presets.set(presetId, newPreset);
                addPresetToDOM(newPreset);
                showToast(`새 프리셋 "${name}"이(가) 생성되었습니다.`, 'success');
            }
            
            updateAllStats();
            closePresetModal();
        });

        function addPresetToDOM(preset) {
            const presetGrid = document.getElementById('presetGrid');
            
            const emptyMessage = presetGrid.querySelector('[style*="grid-column"]');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            const presetElement = document.createElement('div');
            presetElement.className = 'preset-card';
            presetElement.id = `preset-${preset.id}`;
            presetElement.innerHTML = createPresetCardHTML(preset);
            
            presetGrid.appendChild(presetElement);
        }

        function updatePresetInDOM(preset) {
            const presetCard = document.getElementById(`preset-${preset.id}`);
            if (presetCard) {
                presetCard.innerHTML = createPresetCardHTML(preset);
            }
        }

        // 🆕 프리셋 카드 HTML 생성 (개선됨)
        function createPresetCardHTML(preset) {
            const group = groups.get(preset.group_id);
            const groupName = group ? group.name : '삭제된 그룹';
            const clientCount = group ? group.client_ids.length : 0;
            
            return `
                <input type="checkbox" class="preset-checkbox" data-preset-id="${preset.id}" onclick="event.stopPropagation()" onchange="updateSelectedPresetCount()">
                <div class="preset-content">
                    <div class="preset-name">${preset.name}</div>
                    ${preset.description ? `<div class="preset-info">${preset.description}</div>` : ''}
                    <div class="preset-info">그룹: ${groupName}</div>
                    <div class="preset-info">${clientCount}대 클라이언트</div>
                </div>
                <div class="preset-actions">
                    <button class="btn btn-primary" onclick="executePreset('${preset.id}')" title="실행">▶️</button>
                    <button class="btn btn-secondary" onclick="editPreset('${preset.id}')" title="편집">✏️</button>
                    <button class="btn btn-danger" onclick="deletePreset('${preset.id}')" title="삭제">🗑️</button>
                </div>
            `;
        }

        // 🆕 프리셋 실행 (개선됨)
        function executePreset(presetId) {
            const preset = presets.get(presetId);
            if (!preset) return;
            
            const group = groups.get(preset.group_id);
            if (!group) {
                showToast('연결된 그룹을 찾을 수 없습니다.', 'error');
                return;
            }
            
            // 온라인 클라이언트만 필터링
            const onlineClients = group.client_ids.filter(clientId => {
                const client = clients.get(clientId);
                return client && client.status !== 'offline';
            });
            
            if (onlineClients.length === 0) {
                showToast('실행 가능한 온라인 클라이언트가 없습니다.', 'error');
                return;
            }
            
            // 실행 기록 생성
            const executionId = `exec_${Date.now()}`;
            const execution = {
                id: executionId,
                preset_id: presetId,
                preset_name: preset.name,
                target_clients: onlineClients,
                status: 'running',
                started_at: new Date(),
                completed_at: null,
                results: {},
                client_commands: preset.client_commands // 🆕 명령어 정보 포함
            };
            
            // 각 클라이언트를 실행 중 상태로 변경
            onlineClients.forEach(clientId => {
                updateClientStatus(clientId, 'running');
                execution.results[clientId] = 'running';
                
                // 실행 ID 표시
                const clientElement = document.querySelector(`[data-client-id="${clientId}"]`);
                if (clientElement) {
                    let execIdElement = clientElement.querySelector('.execution-id');
                    if (!execIdElement) {
                        execIdElement = document.createElement('div');
                        execIdElement.className = 'execution-id';
                        clientElement.appendChild(execIdElement);
                    }
                    execIdElement.textContent = executionId.slice(-6);
                }
            });
            
            // 프리셋 카드 활성화
            const presetCard = document.getElementById(`preset-${presetId}`);
            presetCard.classList.add('active');
            preset.is_active = true;
            presets.set(presetId, preset);
            
            executions.set(executionId, execution);
            
            showToast(`프리셋 "${preset.name}"이(가) ${onlineClients.length}개 클라이언트에서 실행되었습니다.`, 'success');
            
            // 실행 완료 시뮬레이션 (10-30초 후)
            setTimeout(() => {
                completeExecution(executionId);
            }, Math.random() * 20000 + 10000);
            
            updateAllStats();
        }

        function completeExecution(executionId) {
            const execution = executions.get(executionId);
            if (!execution) return;
            
            execution.status = 'completed';
            execution.completed_at = new Date();
            
            // 클라이언트들을 온라인 상태로 변경
            execution.target_clients.forEach(clientId => {
                execution.results[clientId] = Math.random() > 0.1 ? 'success' : 'failed';
                updateClientStatus(clientId, 'online');
                
                // 실행 ID 제거
                const clientElement = document.querySelector(`[data-client-id="${clientId}"]`);
                if (clientElement) {
                    const execIdElement = clientElement.querySelector('.execution-id');
                    if (execIdElement) {
                        execIdElement.remove();
                    }
                }
            });
            
            // 프리셋 카드 비활성화
            const presetCard = document.getElementById(`preset-${execution.preset_id}`);
            if (presetCard) {
                presetCard.classList.remove('active');
            }
            
            const preset = presets.get(execution.preset_id);
            if (preset) {
                preset.is_active = false;
                presets.set(execution.preset_id, preset);
            }
            
            executions.set(executionId, execution);
            
            const successCount = Object.values(execution.results).filter(r => r === 'success').length;
            const failedCount = Object.values(execution.results).filter(r => r === 'failed').length;
            
            showToast(`프리셋 실행 완료: 성공 ${successCount}개, 실패 ${failedCount}개`, 
                     failedCount === 0 ? 'success' : 'warning');
            
            updateAllStats();
        }

        function deletePreset(presetId) {
            const preset = presets.get(presetId);
            if (!preset) return;
            
            if (confirm(`정말 "${preset.name}" 프리셋을 삭제하시겠습니까?\n실행 중인 경우 자동으로 중지됩니다.`)) {
                // 실행 중이면 중지
                if (preset.is_active) {
                    stopActiveExecutions(presetId);
                }
                
                // DOM에서 제거
                const presetCard = document.getElementById(`preset-${presetId}`);
                if (presetCard) {
                    presetCard.remove();
                }
                
                // 데이터에서 제거
                presets.delete(presetId);
                
                // 선택된 항목에서 제거
                selectedPresets.delete(presetId);
                updateSelectedPresetCount();
                
                updateAllStats();
                
                showToast(`프리셋 "${preset.name}"이(가) 삭제되었습니다.`, 'error');
            }
        }

        function stopActiveExecutions(presetId) {
            const activeExecutions = Array.from(executions.values()).filter(exec => 
                exec.preset_id === presetId && exec.status === 'running'
            );
            
            activeExecutions.forEach(execution => {
                execution.status = 'cancelled';
                execution.completed_at = new Date();
                
                execution.target_clients.forEach(clientId => {
                    execution.results[clientId] = 'cancelled';
                    updateClientStatus(clientId, 'online');
                    
                    // 실행 ID 제거
                    const clientElement = document.querySelector(`[data-client-id="${clientId}"]`);
                    if (clientElement) {
                        const execIdElement = clientElement.querySelector('.execution-id');
                        if (execIdElement) {
                            execIdElement.remove();
                        }
                    }
                });
                
                executions.set(execution.id, execution);
            });
        }

        // ==================== 일괄 제어 기능 ====================
        function toggleSelectAllPresets() {
            const selectAll = document.getElementById('selectAllPresets');
            const checkboxes = document.querySelectorAll('.preset-checkbox');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAll.checked;
            });
            
            updateSelectedPresetCount();
        }

        function toggleSelectAllGroups() {
            const selectAll = document.getElementById('selectAllGroups');
            const checkboxes = document.querySelectorAll('.group-checkbox');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAll.checked;
            });
            
            updateSelectedGroupCount();
        }

        function updateSelectedPresetCount() {
            const checkedBoxes = document.querySelectorAll('.preset-checkbox:checked');
            document.getElementById('selectedPresetCount').textContent = checkedBoxes.length;
            selectedPresets = new Set(Array.from(checkedBoxes).map(cb => cb.dataset.presetId));
        }

        function updateSelectedGroupCount() {
            const checkedBoxes = document.querySelectorAll('.group-checkbox:checked');
            document.getElementById('selectedGroupCount').textContent = checkedBoxes.length;
            selectedGroups = new Set(Array.from(checkedBoxes).map(cb => cb.dataset.groupId));
        }

        function bulkPresetAction(action) {
            if (selectedPresets.size === 0) {
                showToast('선택된 프리셋이 없습니다.', 'error');
                return;
            }
            
            const actionNames = {
                'execute': '실행',
                'stop': '정지', 
                'delete': '삭제'
            };
            
            const actionName = actionNames[action];
            const presetCount = selectedPresets.size;
            
            if (action === 'delete') {
                if (confirm(`선택된 ${presetCount}개 프리셋을 모두 삭제하시겠습니까?\n실행 중인 프리셋은 자동으로 중지됩니다.`)) {
                    selectedPresets.forEach(presetId => {
                        deletePreset(presetId);
                    });
                    
                    selectedPresets.clear();
                    document.getElementById('selectAllPresets').checked = false;
                    updateSelectedPresetCount();
                }
            } else if (action === 'execute') {
                if (confirm(`선택된 ${presetCount}개 프리셋을 모두 실행하시겠습니까?`)) {
                    let executed = 0;
                    selectedPresets.forEach(presetId => {
                        const preset = presets.get(presetId);
                        if (preset && !preset.is_active) {
                            executePreset(presetId);
                            executed++;
                        }
                    });
                    showToast(`${executed}개 프리셋이 실행되었습니다.`, 'success');
                }
            } else if (action === 'stop') {
                if (confirm(`선택된 ${presetCount}개 프리셋을 모두 정지하시겠습니까?`)) {
                    let stopped = 0;
                    selectedPresets.forEach(presetId => {
                        const preset = presets.get(presetId);
                        if (preset && preset.is_active) {
                            stopActiveExecutions(presetId);
                            stopped++;
                        }
                    });
                    showToast(`${stopped}개 프리셋이 정지되었습니다.`, 'success');
                }
            }
        }

        function bulkGroupAction(action) {
            if (selectedGroups.size === 0) {
                showToast('선택된 그룹이 없습니다.', 'error');
                return;
            }
            
            const actionNames = {
                'on': '켜기',
                'reboot': '재부팅',
                'off': '끄기'
            };
            
            const actionName = actionNames[action];
            const groupCount = selectedGroups.size;
            
            if (confirm(`선택된 ${groupCount}개 그룹의 모든 디스플레이 서버를 ${actionName} 하시겠습니까?`)) {
                let totalClients = 0;
                selectedGroups.forEach(groupId => {
                    const group = groups.get(groupId);
                    if (group) {
                        totalClients += group.client_ids.length;
                    }
                });
                
                showToast(`${groupCount}개 그룹 (${totalClients}대 클라이언트)에 전원 ${actionName} 명령을 전송했습니다. (v2.1에서 활성화)`, 'info');
            }
        }

        // ==================== 토스트 및 모달 관리 ====================
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast';
            if (type) toast.classList.add(type);
            toast.style.display = 'block';
            
            setTimeout(() => {
                toast.style.display = 'none';
            }, 4000);
        }

        // 모달 외부 클릭 시 닫기
        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                if (event.target.id === 'clientModal') {
                    closeModal();
                } else if (event.target.id === 'presetModal') {
                    closePresetModal();
                } else if (event.target.id === 'groupModal') {
                    closeGroupModal();
                } else if (event.target.id === 'addClientModal') {
                    closeAddClientModal();
                }
            }
        };

        // ==================== 데모 데이터 생성 (개발용) ====================
        function createDemoData() {
            // 데모 클라이언트 생성
            const demoClients = [
                { name: 'Display_01', ip: '192.168.1.101', status: 'online' },
                { name: 'Display_02', ip: '192.168.1.102', status: 'running' },
                { name: 'Display_03', ip: '192.168.1.103', status: 'offline' },
                { name: 'Display_04', ip: '192.168.1.104', status: 'online' }
            ];
            
            demoClients.forEach((clientData, index) => {
                const clientId = `demo_client_${index + 1}`;
                const client = {
                    id: clientId,
                    name: clientData.name,
                    ip_address: clientData.ip,
                    port: 8081,
                    description: `데모 클라이언트 ${index + 1}`,
                    status: clientData.status,
                    created_at: new Date(Date.now() - (index * 86400000)),
                    last_seen: clientData.status !== 'offline' ? new Date() : null
                };
                
                clients.set(clientId, client);
                addClientToDOM(client);
            });
            
            // 데모 그룹 생성
            setTimeout(() => {
                const groupId = 'demo_group_1';
                const group = {
                    id: groupId,
                    name: '메인 디스플레이 월',
                    description: '중앙 메인 디스플레이 구역',
                    client_ids: ['demo_client_1', 'demo_client_2', 'demo_client_4'],
                    created_at: new Date()
                };
                
                groups.set(groupId, group);
                addGroupToDOM(group);
                updateGroupClientList();
                updatePresetGroupList();
            }, 500);
            
            // 데모 프리셋 생성
            setTimeout(() => {
                const presetId = 'demo_preset_1';
                const preset = {
                    id: presetId,
                    name: '메인 콘텐츠 재생',
                    description: '4K 메인 콘텐츠 스트리밍',
                    group_id: 'demo_group_1', // 🆕 단일 그룹 ID
                    client_commands: { // 🆕 클라이언트별 명령어
                        'demo_client_1': 'D:\\UnrealProjects\\MainContent\\Windows\\MainContent.exe -dc_node=Node_0 -fullscreen',
                        'demo_client_2': 'D:\\UnrealProjects\\MainContent\\Windows\\MainContent.exe -dc_node=Node_1 -fullscreen',
                        'demo_client_4': 'D:\\UnrealProjects\\MainContent\\Windows\\MainContent.exe -dc_node=Node_2 -fullscreen'
                    },
                    created_at: new Date(),
                    is_active: false
                };
                
                presets.set(presetId, preset);
                addPresetToDOM(preset);
            }, 1000);
            
            updateAllStats();
            showToast('🎮 데모 데이터가 로드되었습니다! 이제 프리셋을 만들어보세요.', 'success');
        }

        // 개발 모드에서 데모 데이터 생성
        setTimeout(() => {
            createDemoData();
        }, 3000);
    </script>
</body>
</html>