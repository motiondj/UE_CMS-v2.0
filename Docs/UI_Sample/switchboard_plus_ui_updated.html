<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Switchboard Plus v2 - nDisplay Control</title>
    <style>
        /* 🎨 CSS 변수 정의 (라이트/다크 테마) */
        :root {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f8fafc;
            --text-primary: #333333;
            --text-secondary: #1e293b;
            --text-muted: #64748b;
            --border-color: #e2e8f0;
            --border-hover: #3b82f6;
            --shadow-color: rgba(0,0,0,0.1);
            --modal-overlay: rgba(0,0,0,0.5);
            
            /* 클라이언트 상태 색상 */
            --client-online: #fef3c7;
            --client-running: #dcfce7;
            --client-offline: #fef2f2;
            
            /* 버튼 색상 */
            --btn-primary: #22c55e;
            --btn-primary-hover: #16a34a;
            --btn-danger: #ef4444;
            --btn-danger-hover: #dc2626;
            --btn-secondary: #64748b;
            --btn-secondary-hover: #475569;
            
            /* 추가 색상 */
            --success-bg: #f0fdf4;
            --warning-bg: #fef3c7;
            --error-bg: #fef2f2;
            --info-bg: #f0f9ff;
        }

        /* 🌙 다크 테마 */
        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #e2e8f0;
            --text-muted: #94a3b8;
            --border-color: #334155;
            --border-hover: #3b82f6;
            --shadow-color: rgba(0,0,0,0.3);
            --modal-overlay: rgba(0,0,0,0.7);
            
            /* 다크 모드 클라이언트 상태 색상 */
            --client-online: #422006;
            --client-running: #14532d;
            --client-offline: #450a0a;
            
            /* 다크 모드 추가 색상 */
            --success-bg: #14532d;
            --warning-bg: #422006;
            --error-bg: #450a0a;
            --info-bg: #1e3a8a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* 🎨 헤더 */
        .header {
            background: linear-gradient(135deg, #4c1d95 0%, #6366f1 50%, #71717a 100%);
            color: white;
            padding: 12px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-info {
            display: flex;
            gap: 15px;
            font-size: 12px;
            align-items: center;
        }

        /* Socket 연결 상태 표시 */
        .socket-status {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .socket-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #22c55e;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .socket-indicator.disconnected {
            background: #ef4444;
            animation: none;
        }

        .settings-btn {
            background: rgba(255,255,255,0.15);
            border: none;
            color: white;
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .settings-btn:hover {
            background: rgba(255,255,255,0.25);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* 📊 통계 바 */
        .stats-bar {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 25px 30px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px var(--shadow-color);
            transition: background-color 0.3s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 30px;
            text-align: center;
        }

        .stat-item {
            padding: 5px;
        }

        .stat-value {
            font-size: 36px;
            font-weight: 700;
            color: #3b82f6;
            line-height: 1;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: 400;
        }

        /* 📋 메인 레이아웃 */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .section {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 1px 3px var(--shadow-color);
            transition: background-color 0.3s ease;
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* 🔘 버튼 스타일 */
        .btn {
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            padding: 0;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .btn-primary {
            background: var(--btn-primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--btn-primary-hover);
        }

        .btn-danger {
            background: var(--btn-danger);
            color: white;
        }

        .btn-danger:hover {
            background: var(--btn-danger-hover);
        }

        .btn-secondary {
            background: var(--btn-secondary);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--btn-secondary-hover);
        }

        /* 텍스트가 있는 버튼 */
        .btn-with-text {
            width: auto;
            padding: 6px 12px;
            font-size: 12px;
            min-width: 80px;
            height: 28px;
        }

        /* 일괄 제어 버튼 */
        .btn-bulk {
            width: auto;
            padding: 4px 8px;
            font-size: 11px;
            min-width: 60px;
            height: 26px;
        }

        /* 📝 프리셋 카드 */
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .preset-card {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
            position: relative;
        }

        .preset-card:hover {
            border-color: var(--border-hover);
            background: var(--bg-tertiary);
        }

        .preset-card.active {
            border-color: #22c55e;
            background: var(--success-bg);
        }

        .preset-checkbox {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 16px;
            height: 16px;
            z-index: 1;
        }

        .preset-content {
            flex: 1;
            margin-left: 24px;
        }

        .preset-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .preset-info {
            font-size: 11px;
            color: var(--text-muted);
            line-height: 1.3;
        }

        .preset-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        /* 👥 그룹 카드 */
        .group-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .group-card {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
            position: relative;
        }

        .group-card:hover {
            border-color: var(--border-hover);
            background: var(--bg-tertiary);
        }

        .group-checkbox {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 16px;
            height: 16px;
            z-index: 1;
        }

        .group-content {
            flex: 1;
            margin-left: 24px;
        }

        .group-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .group-info {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .group-clients {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .group-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
            align-items: center;
        }

        .client-tag {
            background: #22c55e;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 500;
        }

        /* 일괄 제어 UI */
        .bulk-controls {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s ease;
        }

        .selection-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .bulk-actions {
            display: flex;
            gap: 6px;
        }

        /* 🖥️ 디스플레이 서버 모니터링 - 개선된 버전 */
        .client-monitor {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 1px 3px var(--shadow-color);
            transition: background-color 0.3s ease;
        }

        .monitor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .client-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }

        .client-item {
            background: var(--client-online);
            border-radius: 6px;
            padding: 12px 8px;
            text-align: center;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            border: 2px solid transparent;
        }

        .client-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .client-item.online {
            background: var(--client-online);
            border-color: #f59e0b;
        }

        .client-item.running {
            background: var(--client-running);
            border-color: #22c55e;
        }

        .client-item.offline {
            background: var(--client-offline);
            border-color: #ef4444;
            opacity: 0.7;
        }

        .client-icon {
            font-size: 24px;
            margin-bottom: 6px;
        }

        .client-name {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 2px;
            color: var(--text-secondary);
        }

        .client-ip {
            font-size: 10px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .client-status {
            font-size: 9px;
            color: var(--text-muted);
            font-weight: 500;
            margin-bottom: 4px;
        }

        /* 성능 메트릭 표시 - 계획서 반영 */
        .client-metrics {
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px solid var(--border-color);
            font-size: 9px;
            color: var(--text-muted);
            line-height: 1.2;
        }

        .client-metrics.visible {
            display: block;
        }

        /* 실행 ID 표시 */
        .execution-id {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 8px;
            font-weight: 600;
        }

        /* 📊 실행 모니터링 섹션 - 계획서 반영 */
        .execution-monitor {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 1px 3px var(--shadow-color);
            transition: background-color 0.3s ease;
        }

        .execution-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 400px;
            overflow-y: auto;
        }

        .execution-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            transition: all 0.2s ease;
        }

        .execution-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .execution-details {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .execution-targets {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
        }

        .target-client {
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 9px;
            font-weight: 500;
        }

        .target-client.success {
            background: var(--success-bg);
            color: #14532d;
        }

        .target-client.failed {
            background: var(--error-bg);
            color: #991b1b;
        }

        .target-client.pending {
            background: var(--warning-bg);
            color: #92400e;
        }

        .execution-status {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 600;
        }

        .execution-status.pending {
            background: var(--warning-bg);
            color: #92400e;
        }

        .execution-status.running {
            background: var(--info-bg);
            color: #1e40af;
        }

        .execution-status.completed {
            background: var(--success-bg);
            color: #14532d;
        }

        .execution-status.failed {
            background: var(--error-bg);
            color: #991b1b;
        }

        .execution-progress {
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }

        .execution-progress-bar {
            height: 100%;
            background: #3b82f6;
            transition: width 0.3s ease;
        }

        /* 모달 스타일 */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-overlay);
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80%;
            overflow-y: auto;
            animation: modalSlideIn 0.3s ease;
            transition: background-color 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-header h3 {
            color: var(--text-secondary);
        }

        .close {
            font-size: 24px;
            cursor: pointer;
            color: var(--text-muted);
        }

        .close:hover {
            color: #ef4444;
        }

        /* 정보 섹션 */
        .info-section {
            margin-bottom: 20px;
        }

        .info-section h4 {
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--text-secondary);
        }

        .info-grid {
            display: grid;
            gap: 8px;
            font-size: 12px;
            color: var(--text-muted);
        }

        /* 버튼 그룹 */
        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* 위험 구역 스타일 */
        .danger-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #fee2e2;
        }

        .warning-text {
            font-size: 11px;
            color: #991b1b;
            margin-top: 5px;
        }

        /* 반응형 디자인 */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 20px;
            }
            
            .preset-grid,
            .group-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 8px;
                text-align: center;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
            }
            
            .section {
                padding: 15px;
            }

            .bulk-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .preset-grid,
            .group-grid {
                grid-template-columns: 1fr;
            }

            .client-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
        }

        /* 폼 스타일 */
        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 13px;
            font-family: inherit;
            transition: border-color 0.2s;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        textarea.form-input {
            resize: vertical;
            min-height: 60px;
        }

        .form-help {
            display: block;
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .checkbox-group {
            display: grid;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            transition: background-color 0.3s ease;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
            color: var(--text-primary);
        }

        .checkbox-label:hover {
            background: var(--border-color);
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        /* 토스트 */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--text-secondary);
            color: white;
            padding: 12px 16px;
            border-radius: 6px;
            display: none;
            animation: slideIn 0.3s ease;
            box-shadow: 0 4px 12px var(--shadow-color);
            font-size: 12px;
            transition: background-color 0.3s ease;
            max-width: 300px;
            z-index: 1001;
        }

        .toast.success {
            background: #22c55e;
        }

        .toast.error {
            background: #ef4444;
        }

        .toast.warning {
            background: #f59e0b;
        }

        .toast.info {
            background: #3b82f6;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
            }
            to {
                transform: translateX(0);
            }
        }

        /* 로딩 스피너 */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* 상태 뱃지 */
        .status-badge {
            display: inline-block;
            padding: 2px 8px;
            font-size: 10px;
            font-weight: 600;
            border-radius: 12px;
            text-transform: uppercase;
        }

        .status-badge.online {
            background: var(--success-bg);
            color: #14532d;
        }

        .status-badge.offline {
            background: var(--error-bg);
            color: #991b1b;
        }

        .status-badge.running {
            background: var(--info-bg);
            color: #1e40af;
        }

        /* 연결 히스토리 표시 */
        .connection-history {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
            font-size: 10px;
            color: var(--text-muted);
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        /* API 연결 상태 표시 */
        .api-status {
            position: fixed;
            top: 70px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 11px;
            box-shadow: 0 2px 8px var(--shadow-color);
            z-index: 999;
            display: none;
        }

        .api-status.visible {
            display: block;
        }

        .api-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }

        .api-indicator.connected {
            background: #22c55e;
        }

        .api-indicator.disconnected {
            background: #ef4444;
        }
    </style>
</head>
<body>
    <!-- API 연결 상태 표시 -->
    <div class="api-status" id="apiStatus">
        <span class="api-indicator disconnected" id="apiIndicator"></span>
        <span id="apiStatusText">API 연결 중...</span>
    </div>

    <!-- 헤더 -->
    <div class="header">
        <div class="header-content">
            <h1>⚡ Switchboard Plus v2.0</h1>
            <div class="status-info">
                <div class="socket-status">
                    Socket 상태: 
                    <span class="socket-indicator" id="socketIndicator"></span>
                    <span style="color: #22c55e; font-weight: 600;" id="socketStatus">연결 중...</span>
                </div>
                <div>시간: <span id="current-time">12:05:15</span></div>
                <div>연결된 클라이언트: <span style="color: #22c55e; font-weight: 600;" id="connectedCount">0</span></div>
                <button class="settings-btn" onclick="toggleDarkMode()" id="themeToggle">🌙</button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- 통계 바 -->
        <div class="stats-bar">
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="totalClients">0</div>
                    <div class="stat-label">전체 디스플레이 서버</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="onlineClients">0</div>
                    <div class="stat-label">온라인</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="runningClients">0</div>
                    <div class="stat-label">실행 중</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="activeExecutions">0</div>
                    <div class="stat-label">활성 실행</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalGroups">0</div>
                    <div class="stat-label">그룹 수</div>
                </div>
            </div>
        </div>

        <!-- 메인 레이아웃 -->
        <div class="main-layout">
            <!-- 콘텐츠 프리셋 -->
            <div class="section">
                <h2 class="section-title">
                    콘텐츠 프리셋
                    <button class="btn btn-secondary btn-with-text" onclick="showAddPresetModal()">
                        ➕ 새 프리셋
                    </button>
                </h2>
                
                <!-- 프리셋 일괄 제어 UI -->
                <div class="bulk-controls">
                    <div class="selection-info">
                        <label>
                            <input type="checkbox" id="selectAllPresets" onchange="toggleSelectAllPresets()">
                            전체 선택
                        </label>
                        <span>선택된 프리셋: <span id="selectedPresetCount">0</span>개</span>
                    </div>
                    <div class="bulk-actions">
                        <button class="btn btn-primary btn-bulk" onclick="bulkPresetAction('execute')" title="선택된 프리셋들 전체 실행">
                            ▶️
                        </button>
                        <button class="btn btn-danger btn-bulk" onclick="bulkPresetAction('stop')" title="선택된 프리셋들 전체 정지">
                            ⏹️
                        </button>
                        <button class="btn btn-danger btn-bulk" onclick="bulkPresetAction('delete')" title="선택된 프리셋들 전체 삭제">
                            🗑️
                        </button>
                    </div>
                </div>

                <div class="preset-grid" id="presetGrid">
                    <!-- 프리셋이 없을 때 표시 -->
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 16px;">📝</div>
                        <div style="font-size: 14px; margin-bottom: 8px;">아직 생성된 프리셋이 없습니다</div>
                        <div style="font-size: 12px;">새 프리셋 버튼을 클릭해서 첫 번째 프리셋을 만들어보세요!</div>
                    </div>
                </div>
            </div>

            <!-- 디스플레이 서버 그룹 -->
            <div class="section">
                <h2 class="section-title">
                    디스플레이 서버 그룹
                    <button class="btn btn-secondary btn-with-text" onclick="showAddGroupModal()">
                        ➕ 새 그룹
                    </button>
                </h2>
                
                <!-- 그룹 일괄 제어 UI -->
                <div class="bulk-controls">
                    <div class="selection-info">
                        <label>
                            <input type="checkbox" id="selectAllGroups" onchange="toggleSelectAllGroups()">
                            전체 선택
                        </label>
                        <span>선택된 그룹: <span id="selectedGroupCount">0</span>개</span>
                    </div>
                    <div class="bulk-actions">
                        <button class="btn btn-primary btn-bulk" onclick="bulkGroupAction('on')" title="선택된 그룹들 전체 켜기">
                            🔌
                        </button>
                        <button class="btn btn-secondary btn-bulk" onclick="bulkGroupAction('reboot')" title="선택된 그룹들 전체 재부팅">
                            🔄
                        </button>
                        <button class="btn btn-danger btn-bulk" onclick="bulkGroupAction('off')" title="선택된 그룹들 전체 끄기">
                            ⚡
                        </button>
                    </div>
                </div>

                <div class="group-grid" id="groupGrid">
                    <!-- 그룹이 없을 때 표시 -->
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 16px;">👥</div>
                        <div style="font-size: 14px; margin-bottom: 8px;">아직 생성된 그룹이 없습니다</div>
                        <div style="font-size: 12px;">새 그룹 버튼을 클릭해서 첫 번째 그룹을 만들어보세요!</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 디스플레이 서버 모니터링 -->
        <div class="client-monitor">
            <div class="monitor-header">
                <h2 class="section-title">
                    디스플레이 서버 모니터링
                    <span style="font-size: 12px; color: var(--text-muted); font-weight: normal;">
                        자동 새로고침: <span id="refreshInterval">30초</span>
                    </span>
                </h2>
                <button class="btn btn-secondary btn-with-text" onclick="showAddClientModal()">
                    ➕ 클라이언트 추가
                </button>
            </div>

            <div class="client-grid" id="clientGrid">
                <!-- 클라이언트가 없을 때 표시 -->
                <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                    <div style="font-size: 48px; margin-bottom: 16px;">🖥️</div>
                    <div style="font-size: 14px; margin-bottom: 8px;">연결된 디스플레이 서버가 없습니다</div>
                    <div style="font-size: 12px;">클라이언트 추가 버튼을 클릭하거나 Python 클라이언트가 연결되면 자동으로 나타납니다</div>
                </div>
            </div>
        </div>

        <!-- 실행 모니터링 섹션 -->
        <div class="execution-monitor" id="executionMonitor" style="display: none;">
            <h2 class="section-title">
                프리셋 실행 히스토리
                <span style="font-size: 12px; color: var(--text-muted); font-weight: normal;">
                    최근 10개 표시 | 자동 업데이트
                </span>
            </h2>
            <div class="execution-list" id="executionList">
                <!-- 실행 히스토리가 여기에 동적으로 추가됩니다 -->
            </div>
        </div>
    </div>

    <!-- 클라이언트 추가 모달 -->
    <div class="modal" id="addClientModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>새 디스플레이 서버 추가</h3>
                <span class="close" onclick="closeAddClientModal()">&times;</span>
            </div>
            
            <div class="modal-body">
                <form id="addClientForm">
                    <div class="form-group">
                        <label for="clientName">클라이언트 이름</label>
                        <input type="text" id="clientName" class="form-input" placeholder="예: Display_01" required>
                        <small class="form-help">알아보기 쉬운 이름을 지정하세요 (중복 불가)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="clientIP">IP 주소</label>
                        <input type="text" id="clientIP" class="form-input" placeholder="192.168.1.101" pattern="^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$" required>
                        <small class="form-help">클라이언트 PC의 고정 IP 주소</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="clientPort">포트</label>
                        <input type="number" id="clientPort" class="form-input" placeholder="8081" value="8081" min="1" max="65535">
                        <small class="form-help">Python 클라이언트 통신 포트 (기본: 8081)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="clientDescription">설명 (선택)</label>
                        <textarea id="clientDescription" class="form-input" rows="2" placeholder="이 클라이언트에 대한 메모 (위치, 용도 등)"></textarea>
                    </div>
                    
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="closeAddClientModal()">취소</button>
                        <button type="submit" class="btn btn-primary">추가</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- 클라이언트 상세 모달 -->
    <div class="modal" id="clientModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalClientName">클라이언트 관리</h3>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            
            <div class="modal-body">
                <!-- 시스템 정보 -->
                <div class="info-section">
                    <h4>시스템 정보</h4>
                    <div class="info-grid">
                        <div>이름: <strong id="modalClientNameText">-</strong></div>
                        <div>IP 주소: <strong id="modalClientIP">-</strong></div>
                        <div>포트: <strong id="modalClientPort">-</strong></div>
                        <div>상태: <span id="modalClientStatus" class="status-badge offline">오프라인</span></div>
                        <div>마지막 연결: <span id="modalLastSeen">-</span></div>
                        <div>현재 실행 ID: <span id="modalExecutionId">없음</span></div>
                    </div>
                </div>
                
                <!-- 성능 메트릭 (실행 중일 때만 표시) -->
                <div class="info-section" id="metricsSection" style="display: none;">
                    <h4>성능 모니터링</h4>
                    <div class="info-grid">
                        <div>CPU 사용률: <span id="modalCPU">0%</span></div>
                        <div>메모리 사용률: <span id="modalRAM">0%</span></div>
                        <div>디스크 사용률: <span id="modalDisk">0%</span></div>
                        <div>네트워크 지연: <span id="modalLatency">0ms</span></div>
                        <div>언리얼엔진 프로세스: <span id="modalProcessCount">0개</span></div>
                    </div>
                </div>
                
                <!-- 실행 중인 프로세스 -->
                <div class="info-section" id="processSection" style="display: none;">
                    <h4>실행 중인 프로세스</h4>
                    <div id="modalProcessList" style="font-size: 12px; color: var(--text-muted); line-height: 1.4;">
                        없음
                    </div>
                </div>
                
                <!-- 연결 히스토리 -->
                <div class="info-section" id="historySection">
                    <h4>연결 히스토리 (최근 5개)</h4>
                    <div class="connection-history" id="modalConnectionHistory">
                        <div class="history-item">
                            <span>등록됨</span>
                            <span id="modalRegisteredTime">-</span>
                        </div>
                    </div>
                </div>
                
                <!-- 클라이언트 제어 -->
                <div class="info-section">
                    <h4>클라이언트 제어</h4>
                    <div class="button-group">
                        <button class="btn btn-primary" onclick="clientAction('heartbeat')" title="상태 확인">
                            💓 상태 확인
                        </button>
                        <button class="btn btn-secondary" onclick="clientAction('stop_all')" title="모든 프로세스 중지">
                            ⏹️ 전체 중지
                        </button>
                    </div>
                </div>
                
                <!-- 전원 제어 (v2.1 기능) -->
                <div class="info-section">
                    <h4>전원 제어 (v2.1)</h4>
                    <div class="button-group">
                        <button class="btn btn-primary" onclick="powerAction('on')" title="Wake-on-LAN으로 전원 켜기" disabled>
                            🔌 전원 켜기
                        </button>
                        <button class="btn btn-secondary" onclick="powerAction('reboot')" title="원격 재부팅" disabled>
                            🔄 재부팅
                        </button>
                        <button class="btn btn-danger" onclick="powerAction('off')" title="원격 종료" disabled>
                            ⚡ 전원 끄기
                        </button>
                    </div>
                    <p class="warning-text">전원 제어 기능은 v2.1에서 활성화됩니다.</p>
                </div>
                
                <!-- 위험 구역 -->
                <div class="danger-section">
                    <h4>위험 구역</h4>
                    <button class="btn btn-danger" onclick="deleteClient()" title="데이터베이스에서 완전 삭제">
                        🗑️ 클라이언트 삭제
                    </button>
                    <p class="warning-text">삭제하면 데이터베이스에서 완전히 제거되며 복구할 수 없습니다.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- 프리셋 추가/편집 모달 -->
    <div class="modal" id="presetModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="presetModalTitle">새 프리셋 만들기</h3>
                <span class="close" onclick="closePresetModal()">&times;</span>
            </div>
            
            <div class="modal-body">
                <form id="presetForm">
                    <div class="form-group">
                        <label for="presetName">프리셋 이름</label>
                        <input type="text" id="presetName" class="form-input" placeholder="예: 메인 콘텐츠" required>
                        <small class="form-help">알아보기 쉬운 프리셋 이름</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="presetDescription">설명 (선택)</label>
                        <textarea id="presetDescription" class="form-input" rows="2" placeholder="프리셋에 대한 설명을 입력하세요"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="presetCommand">언리얼엔진 실행 명령</label>
                        <textarea id="presetCommand" class="form-input" rows="6" placeholder="D:\UnrealProjects\MyProject\Windows\MyProject.exe None -messaging -dc_cluster -nosplash -dc_cfg=&quot;C:\path\to\config.ndisplay&quot; -dc_node=Node_0 -fullscreen" required></textarea>
                        <small class="form-help">스위치보드에서 생성된 전체 명령어를 복사해서 붙여넣으세요. 매우 긴 명령어도 지원됩니다.</small>
                    </div>
                    
                    <div class="form-group">
                        <label>대상 그룹 선택 (복수 선택 가능)</label>
                        <div class="checkbox-group" id="presetGroupList">
                            <!-- 그룹 목록이 동적으로 추가됩니다 -->
                            <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                                먼저 그룹을 생성해주세요
                            </div>
                        </div>
                        <small class="form-help">이 프리셋을 실행할 그룹을 선택하세요. 선택한 그룹의 모든 클라이언트에서 실행됩니다.</small>
                    </div>
                    
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="closePresetModal()">취소</button>
                        <button type="submit" class="btn btn-primary">저장</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- 그룹 추가/편집 모달 -->
    <div class="modal" id="groupModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="groupModalTitle">새 그룹 만들기</h3>
                <span class="close" onclick="closeGroupModal()">&times;</span>
            </div>
            
            <div class="modal-body">
                <form id="groupForm">
                    <div class="form-group">
                        <label for="groupName">그룹 이름</label>
                        <input type="text" id="groupName" class="form-input" placeholder="예: 메인 디스플레이 월" required>
                        <small class="form-help">알아보기 쉬운 그룹 이름</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="groupDescription">설명 (선택)</label>
                        <textarea id="groupDescription" class="form-input" rows="2" placeholder="그룹에 대한 설명을 입력하세요 (위치, 용도 등)"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label>포함할 디스플레이 서버</label>
                        <div class="checkbox-group" id="groupClientList">
                            <!-- 클라이언트 목록이 동적으로 추가됩니다 -->
                            <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                                먼저 클라이언트를 추가해주세요
                            </div>
                        </div>
                        <small class="form-help">그룹에 포함할 디스플레이 서버를 선택하세요. 한 클라이언트는 여러 그룹에 포함될 수 있습니다.</small>
                    </div>
                    
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="closeGroupModal()">취소</button>
                        <button type="submit" class="btn btn-primary">저장</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- 토스트 알림 -->
    <div class="toast" id="toast"></div>

    <script>
        // ==================== 전역 상태 관리 ====================
        let isDarkMode = false;
        let isSocketConnected = false;
        let isApiConnected = false;
        let selectedGroups = new Set();
        let selectedPresets = new Set();
        let currentClientId = null;
        let editingPresetId = null;
        let editingGroupId = null;
        let autoRefreshTimer = null;

        // 데이터 저장소 (실제 구현에서는 서버에서 관리)
        let clients = new Map();
        let groups = new Map();
        let presets = new Map();
        let executions = new Map();
        let clientHistory = new Map();

        // Socket.io 연결 (실제 구현에서 활성화)
        // const socket = io();

        // ==================== 초기화 ====================
        window.onload = function() {
            initializeTheme();
            initializeAPI();
            initializeSocket();
            startAutoRefresh();
            updateTime();
            setInterval(updateTime, 1000);
            updateAllStats();
        };

        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                toggleDarkMode();
            }
        }

        function initializeAPI() {
            // API 연결 상태 시뮬레이션
            showApiStatus('connecting');
            
            setTimeout(() => {
                // 실제 구현에서는 서버 ping 체크
                isApiConnected = Math.random() > 0.2; // 80% 확률로 연결
                showApiStatus(isApiConnected ? 'connected' : 'failed');
                
                if (isApiConnected) {
                    loadInitialData();
                }
            }, 2000);

            // 주기적 API 상태 체크
            setInterval(() => {
                checkApiConnection();
            }, 30000);
        }

        function initializeSocket() {
            // Socket.io 연결 상태 시뮬레이션
            setTimeout(() => {
                isSocketConnected = Math.random() > 0.1; // 90% 확률로 연결
                updateSocketStatus();
                
                if (isSocketConnected) {
                    simulateRealTimeUpdates();
                }
            }, 1500);
        }

        function loadInitialData() {
            // 실제 구현에서는 서버에서 데이터 로드
            // fetch('/api/clients').then(response => response.json()).then(data => { ... });
            showToast('초기 데이터를 로드했습니다.', 'success');
        }

        // ==================== 시간 및 자동 새로고침 ====================
        function updateTime() {
            const now = new Date();
            document.getElementById('current-time').textContent = 
                now.toLocaleTimeString('ko-KR', {hour12: true, hour: '2-digit', minute: '2-digit', second: '2-digit'});
        }

        function startAutoRefresh() {
            autoRefreshTimer = setInterval(() => {
                if (isApiConnected) {
                    refreshClientsData();
                }
            }, 30000); // 30초마다 자동 새로고침
        }

        function refreshClientsData() {
            // 실제 구현에서는 서버에서 클라이언트 상태 업데이트
            console.log('클라이언트 데이터 자동 새로고침...');
            
            // 시뮬레이션: 랜덤하게 클라이언트 상태 변경
            document.querySelectorAll('.client-item').forEach(item => {
                if (Math.random() < 0.1) { // 10% 확률로 상태 변경
                    simulateClientStatusChange(item);
                }
            });
        }

        // ==================== API 및 Socket 상태 관리 ====================
        function showApiStatus(status) {
            const apiStatus = document.getElementById('apiStatus');
            const indicator = document.getElementById('apiIndicator');
            const statusText = document.getElementById('apiStatusText');
            
            apiStatus.classList.add('visible');
            
            switch(status) {
                case 'connecting':
                    indicator.className = 'api-indicator disconnected';
                    statusText.textContent = 'API 연결 중...';
                    break;
                case 'connected':
                    indicator.className = 'api-indicator connected';
                    statusText.textContent = 'API 연결됨';
                    setTimeout(() => apiStatus.classList.remove('visible'), 3000);
                    break;
                case 'failed':
                    indicator.className = 'api-indicator disconnected';
                    statusText.textContent = 'API 연결 실패';
                    break;
            }
        }

        function checkApiConnection() {
            // 실제 구현에서는 서버에 ping 요청
            const wasConnected = isApiConnected;
            isApiConnected = Math.random() > 0.15; // 85% 확률로 연결 유지
            
            if (wasConnected !== isApiConnected) {
                showApiStatus(isApiConnected ? 'connected' : 'failed');
                if (!isApiConnected) {
                    showToast('API 연결이 끊어졌습니다. 재연결 시도 중...', 'error');
                }
            }
        }

        function updateSocketStatus() {
            const indicator = document.getElementById('socketIndicator');
            const status = document.getElementById('socketStatus');
            
            if (isSocketConnected) {
                indicator.classList.remove('disconnected');
                status.textContent = '연결됨';
                status.style.color = '#22c55e';
            } else {
                indicator.classList.add('disconnected');
                status.textContent = '연결 끊김';
                status.style.color = '#ef4444';
            }
        }

        // ==================== 실시간 업데이트 시뮬레이션 ====================
        function simulateRealTimeUpdates() {
            // 실제 Socket 이벤트 대신 시뮬레이션
            setInterval(() => {
                if (isSocketConnected && clients.size > 0) {
                    simulateRandomClientUpdate();
                }
            }, 15000); // 15초마다 랜덤 업데이트
        }

        function simulateRandomClientUpdate() {
            const clientElements = document.querySelectorAll('.client-item');
            if (clientElements.length > 0) {
                const randomClient = clientElements[Math.floor(Math.random() * clientElements.length)];
                simulateClientStatusChange(randomClient);
            }
        }

        function simulateClientStatusChange(clientElement) {
            const clientId = clientElement.getAttribute('data-client-id');
            const currentStatus = clientElement.classList.contains('running') ? 'running' : 
                                 clientElement.classList.contains('online') ? 'online' : 'offline';
            
            let newStatus = currentStatus;
            
            // 상태 변경 로직
            if (currentStatus === 'offline' && Math.random() < 0.3) {
                newStatus = 'online';
            } else if (currentStatus === 'online' && Math.random() < 0.2) {
                newStatus = Math.random() < 0.5 ? 'running' : 'offline';
            } else if (currentStatus === 'running' && Math.random() < 0.1) {
                newStatus = 'online';
            }
            
            if (newStatus !== currentStatus) {
                updateClientStatus(clientId, newStatus);
                addClientHistory(clientId, `상태 변경: ${currentStatus} → ${newStatus}`);
            }
        }

        function updateClientStatus(clientId, status) {
            const clientElement = document.querySelector(`[data-client-id="${clientId}"]`);
            if (!clientElement) return;
            
            // 클래스 업데이트
            clientElement.className = `client-item ${status}`;
            
            // 아이콘 및 텍스트 업데이트
            const icon = clientElement.querySelector('.client-icon');
            const statusText = clientElement.querySelector('.client-status');
            const metricsDiv = clientElement.querySelector('.client-metrics');
            
            switch(status) {
                case 'online':
                    icon.textContent = '🟡';
                    statusText.textContent = '대기 중';
                    if (metricsDiv) metricsDiv.style.display = 'none';
                    break;
                case 'running':
                    icon.textContent = '🟢';
                    statusText.textContent = '언리얼엔진 실행 중';
                    if (metricsDiv) {
                        metricsDiv.style.display = 'block';
                        updateClientMetrics(clientId);
                    }
                    break;
                case 'offline':
                    icon.textContent = '🔴';
                    statusText.textContent = '오프라인';
                    if (metricsDiv) metricsDiv.style.display = 'none';
                    break;
            }
            
            // 데이터 저장소 업데이트
            if (clients.has(clientId)) {
                const client = clients.get(clientId);
                client.status = status;
                client.last_seen = new Date();
                clients.set(clientId, client);
            }
            
            updateAllStats();
        }

        function updateClientMetrics(clientId) {
            const metricsDiv = document.querySelector(`[data-client-id="${clientId}"] .client-metrics`);
            if (metricsDiv) {
                const cpu = Math.floor(Math.random() * 100);
                const ram = Math.floor(Math.random() * 100);
                const latency = Math.floor(Math.random() * 50) + 10;
                
                metricsDiv.innerHTML = `
                    CPU: ${cpu}%<br>
                    RAM: ${ram}%<br>
                    지연: ${latency}ms
                `;
            }
        }

        function addClientHistory(clientId, event) {
            if (!clientHistory.has(clientId)) {
                clientHistory.set(clientId, []);
            }
            
            const history = clientHistory.get(clientId);
            history.unshift({
                event: event,
                timestamp: new Date()
            });
            
            // 최대 10개 기록만 유지
            if (history.length > 10) {
                history.splice(10);
            }
            
            clientHistory.set(clientId, history);
        }

        // ==================== 테마 관리 ====================
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            const body = document.body;
            const themeToggle = document.getElementById('themeToggle');
            
            if (isDarkMode) {
                body.setAttribute('data-theme', 'dark');
                themeToggle.textContent = '☀️';
                localStorage.setItem('theme', 'dark');
                showToast('다크 모드가 활성화되었습니다.', 'success');
            } else {
                body.removeAttribute('data-theme');
                themeToggle.textContent = '🌙';
                localStorage.setItem('theme', 'light');
                showToast('라이트 모드가 활성화되었습니다.', 'success');
            }
        }

        // ==================== 통계 업데이트 ====================
        function updateAllStats() {
            const runningClients = document.querySelectorAll('.client-item.running').length;
            const onlineClients = document.querySelectorAll('.client-item.online, .client-item.running').length;
            const totalClients = document.querySelectorAll('.client-item').length;
            const totalGroups = document.querySelectorAll('.group-card').length;
            const totalPresets = document.querySelectorAll('.preset-card').length;
            const activeExecutionsCount = document.querySelectorAll('.execution-item .execution-status.running').length;
            
            document.getElementById('totalClients').textContent = totalClients;
            document.getElementById('runningClients').textContent = runningClients;
            document.getElementById('onlineClients').textContent = onlineClients;
            document.getElementById('activeExecutions').textContent = activeExecutionsCount;
            document.getElementById('totalGroups').textContent = totalGroups;
            document.getElementById('connectedCount').textContent = onlineClients;
            
            // 빈 상태 메시지 관리
            updateEmptyStates();
        }

        function updateEmptyStates() {
            const presetGrid = document.getElementById('presetGrid');
            const groupGrid = document.getElementById('groupGrid');
            const clientGrid = document.getElementById('clientGrid');
            
            // 프리셋 빈 상태
            const presetCards = presetGrid.querySelectorAll('.preset-card');
            const presetEmpty = presetGrid.querySelector('[style*="grid-column"]');
            if (presetCards.length === 0 && !presetEmpty) {
                presetGrid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 16px;">📝</div>
                        <div style="font-size: 14px; margin-bottom: 8px;">아직 생성된 프리셋이 없습니다</div>
                        <div style="font-size: 12px;">새 프리셋 버튼을 클릭해서 첫 번째 프리셋을 만들어보세요!</div>
                    </div>
                `;
            } else if (presetCards.length > 0 && presetEmpty) {
                presetEmpty.remove();
            }
            
            // 그룹 빈 상태
            const groupCards = groupGrid.querySelectorAll('.group-card');
            const groupEmpty = groupGrid.querySelector('[style*="grid-column"]');
            if (groupCards.length === 0 && !groupEmpty) {
                groupGrid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 16px;">👥</div>
                        <div style="font-size: 14px; margin-bottom: 8px;">아직 생성된 그룹이 없습니다</div>
                        <div style="font-size: 12px;">새 그룹 버튼을 클릭해서 첫 번째 그룹을 만들어보세요!</div>
                    </div>
                `;
            } else if (groupCards.length > 0 && groupEmpty) {
                groupEmpty.remove();
            }
            
            // 클라이언트 빈 상태
            const clientItems = clientGrid.querySelectorAll('.client-item');
            const clientEmpty = clientGrid.querySelector('[style*="grid-column"]');
            if (clientItems.length === 0 && !clientEmpty) {
                clientGrid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-muted);">
                        <div style="font-size: 48px; margin-bottom: 16px;">🖥️</div>
                        <div style="font-size: 14px; margin-bottom: 8px;">연결된 디스플레이 서버가 없습니다</div>
                        <div style="font-size: 12px;">클라이언트 추가 버튼을 클릭하거나 Python 클라이언트가 연결되면 자동으로 나타납니다</div>
                    </div>
                `;
            } else if (clientItems.length > 0 && clientEmpty) {
                clientEmpty.remove();
            }
        }

        // ==================== 클라이언트 관리 ====================
        function showAddClientModal() {
            document.getElementById('addClientModal').style.display = 'flex';
            document.getElementById('addClientForm').reset();
        }

        function closeAddClientModal() {
            document.getElementById('addClientModal').style.display = 'none';
        }

        // 클라이언트 추가 폼 제출
        document.getElementById('addClientForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const name = document.getElementById('clientName').value.trim();
            const ip = document.getElementById('clientIP').value.trim();
            const port = parseInt(document.getElementById('clientPort').value) || 8081;
            const description = document.getElementById('clientDescription').value.trim();
            
            // 중복 체크
            const existingNames = Array.from(clients.values()).map(c => c.name);
            const existingIPs = Array.from(clients.values()).map(c => c.ip_address);
            
            if (existingNames.includes(name)) {
                showToast('이미 존재하는 클라이언트 이름입니다.', 'error');
                return;
            }
            
            if (existingIPs.includes(ip)) {
                showToast('이미 등록된 IP 주소입니다.', 'error');
                return;
            }
            
            // 새 클라이언트 생성
            const clientId = `client_${Date.now()}`;
            const newClient = {
                id: clientId,
                name: name,
                ip_address: ip,
                port: port,
                description: description,
                status: 'offline',
                created_at: new Date(),
                last_seen: null
            };
            
            clients.set(clientId, newClient);
            addClientToDOM(newClient);
            addClientHistory(clientId, '클라이언트 등록됨');
            
            // 등록 후 연결 확인 시뮬레이션
            setTimeout(() => {
                verifyClientConnection(clientId);
            }, 2000);
            
            updateGroupClientList();
            updateAllStats();
            closeAddClientModal();
            
            showToast(`클라이언트 "${name}"이(가) 추가되었습니다. 연결을 확인하고 있습니다...`, 'success');
        });

        function addClientToDOM(client) {
            const clientGrid = document.getElementById('clientGrid');
            
            // 빈 상태 메시지 제거
            const emptyMessage = clientGrid.querySelector('[style*="grid-column"]');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            const clientElement = document.createElement('div');
            clientElement.className = 'client-item offline';
            clientElement.setAttribute('data-client-id', client.id);
            clientElement.onclick = () => showClientModal(client.id);
            
            clientElement.innerHTML = `
                <div class="client-icon">🔴</div>
                <div class="client-name">${client.name}</div>
                <div class="client-ip">${client.ip_address}</div>
                <div class="client-status">오프라인</div>
                <div class="client-metrics" style="display: none;">
                    CPU: 0%<br>RAM: 0%<br>지연: 0ms
                </div>
            `;
            
            clientGrid.appendChild(clientElement);
        }

        function verifyClientConnection(clientId) {
            // 실제 구현에서는 서버가 클라이언트에게 ping 요청
            const success = Math.random() > 0.3; // 70% 확률로 성공
            
            if (success) {
                updateClientStatus(clientId, 'online');
                const client = clients.get(clientId);
                showToast(`클라이언트 "${client.name}"이(가) 연결되었습니다!`, 'success');
                addClientHistory(clientId, '연결 확인됨');
            } else {
                const client = clients.get(clientId);
                showToast(`클라이언트 "${client.name}"이(가) 응답하지 않습니다. 네트워크를 확인해주세요.`, 'warning');
                addClientHistory(clientId, '연결 실패 - 응답 없음');
            }
        }

        function showClientModal(clientId) {
            currentClientId = clientId;
            const client = clients.get(clientId);
            
            if (!client) return;
            
            // 기본 정보 설정
            document.getElementById('modalClientName').textContent = `${client.name} 관리`;
            document.getElementById('modalClientNameText').textContent = client.name;
            document.getElementById('modalClientIP').textContent = client.ip_address;
            document.getElementById('modalClientPort').textContent = client.port;
            document.getElementById('modalLastSeen').textContent = client.last_seen ? 
                formatRelativeTime(client.last_seen) : '연결된 적 없음';
            document.getElementById('modalRegisteredTime').textContent = 
                formatRelativeTime(client.created_at);
            
            // 상태 뱃지 업데이트
            const statusBadge = document.getElementById('modalClientStatus');
            statusBadge.className = `status-badge ${client.status}`;
            statusBadge.textContent = getStatusText(client.status);
            
            // 실행 ID 설정 (실행 중일 때만)
            const executionIdElement = document.getElementById('modalExecutionId');
            if (client.status === 'running') {
                executionIdElement.textContent = `exec_${clientId}_${Date.now().toString().slice(-6)}`;
            } else {
                executionIdElement.textContent = '없음';
            }
            
            // 성능 메트릭 섹션
            const metricsSection = document.getElementById('metricsSection');
            const processSection = document.getElementById('processSection');
            
            if (client.status === 'running') {
                metricsSection.style.display = 'block';
                processSection.style.display = 'block';
                
                // 더미 메트릭 데이터
                document.getElementById('modalCPU').textContent = Math.floor(Math.random() * 100) + '%';
                document.getElementById('modalRAM').textContent = Math.floor(Math.random() * 100) + '%';
                document.getElementById('modalDisk').textContent = Math.floor(Math.random() * 100) + '%';
                document.getElementById('modalLatency').textContent = Math.floor(Math.random() * 50) + 10 + 'ms';
                document.getElementById('modalProcessCount').textContent = Math.floor(Math.random() * 3) + 1 + '개';
                
                document.getElementById('modalProcessList').innerHTML = `
                    UnrealEngine-Win64-Shipping.exe (PID: ${Math.floor(Math.random() * 10000) + 1000})<br>
                    nDisplayLauncher.exe (PID: ${Math.floor(Math.random() * 10000) + 1000})<br>
                    ${Math.random() > 0.5 ? `nDisplayListener.exe (PID: ${Math.floor(Math.random() * 10000) + 1000})` : ''}
                `;
            } else {
                metricsSection.style.display = 'none';
                processSection.style.display = 'none';
            }
            
            // 연결 히스토리 업데이트
            updateModalConnectionHistory(clientId);
            
            document.getElementById('clientModal').style.display = 'flex';
        }

        function updateModalConnectionHistory(clientId) {
            const historyContainer = document.getElementById('modalConnectionHistory');
            const history = clientHistory.get(clientId) || [];
            
            historyContainer.innerHTML = `
                <div class="history-item">
                    <span>등록됨</span>
                    <span>${formatRelativeTime(clients.get(clientId).created_at)}</span>
                </div>
                ${history.slice(0, 4).map(item => `
                    <div class="history-item">
                        <span>${item.event}</span>
                        <span>${formatRelativeTime(item.timestamp)}</span>
                    </div>
                `).join('')}
            `;
        }

        function formatRelativeTime(date) {
            const now = new Date();
            const diff = now - date;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (minutes < 1) return '방금 전';
            if (minutes < 60) return `${minutes}분 전`;
            if (hours < 24) return `${hours}시간 전`;
            return `${days}일 전`;
        }

        function getStatusText(status) {
            const statusTexts = {
                'online': '온라인',
                'running': '실행 중',
                'offline': '오프라인'
            };
            return statusTexts[status] || status;
        }

        function closeModal() {
            document.getElementById('clientModal').style.display = 'none';
            currentClientId = null;
        }

        function clientAction(action) {
            const client = clients.get(currentClientId);
            if (!client) return;
            
            switch(action) {
                case 'heartbeat':
                    showToast(`"${client.name}"에 상태 확인 요청을 전송했습니다.`, 'info');
                    // 실제 구현: socket.emit('client_heartbeat_request', { clientId: currentClientId });
                    break;
                case 'stop_all':
                    if (client.status === 'running') {
                        updateClientStatus(currentClientId, 'online');
                        showToast(`"${client.name}"의 모든 프로세스 중지 명령을 전송했습니다.`, 'success');
                        addClientHistory(currentClientId, '모든 프로세스 중지됨');
                        updateModalConnectionHistory(currentClientId);
                    } else {
                        showToast('실행 중인 프로세스가 없습니다.', 'warning');
                    }
                    break;
            }
        }

        function powerAction(action) {
            const actionNames = {
                'on': '켜기',
                'reboot': '재부팅',
                'off': '끄기'
            };
            showToast(`전원 ${actionNames[action]} 기능은 v2.1에서 활성화됩니다.`, 'info');
        }

        function deleteClient() {
            const client = clients.get(currentClientId);
            if (!client) return;
            
            if (confirm(`정말 "${client.name}" 클라이언트를 삭제하시겠습니까?\n실행 중인 프로세스는 자동으로 중지됩니다.`)) {
                // DOM에서 제거
                const clientElement = document.querySelector(`[data-client-id="${currentClientId}"]`);
                if (clientElement) {
                    clientElement.remove();
                }
                
                // 데이터에서 제거
                clients.delete(currentClientId);
                clientHistory.delete(currentClientId);
                
                // 선택된 항목에서 제거
                selectedGroups.delete(currentClientId);
                
                updateGroupClientList();
                updateAllStats();
                closeModal();
                
                showToast(`클라이언트 "${client.name}"이(가) 삭제되었습니다.`, 'error');
            }
        }

        // ==================== 그룹 관리 ====================
        function showAddGroupModal() {
            editingGroupId = null;
            document.getElementById('groupModalTitle').textContent = '새 그룹 만들기';
            document.getElementById('groupForm').reset();
            updateGroupClientList();
            document.getElementById('groupModal').style.display = 'flex';
        }

        function editGroup(groupId) {
            editingGroupId = groupId;
            document.getElementById('groupModalTitle').textContent = '그룹 편집';
            
            const group = groups.get(groupId);
            if (group) {
                document.getElementById('groupName').value = group.name;
                document.getElementById('groupDescription').value = group.description || '';
                
                updateGroupClientList();
                
                // 기존 선택된 클라이언트 체크
                group.client_ids.forEach(clientId => {
                    const checkbox = document.querySelector(`input[name="groupClients"][value="${clientId}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }
            
            document.getElementById('groupModal').style.display = 'flex';
        }

        function closeGroupModal() {
            document.getElementById('groupModal').style.display = 'none';
            document.getElementById('groupForm').reset();
            editingGroupId = null;
        }

        function updateGroupClientList() {
            const clientList = document.getElementById('groupClientList');
            
            if (clients.size === 0) {
                clientList.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                        먼저 클라이언트를 추가해주세요
                    </div>
                `;
                return;
            }
            
            clientList.innerHTML = '';
            clients.forEach((client, clientId) => {
                const label = document.createElement('label');
                label.className = 'checkbox-label';
                label.innerHTML = `
                    <input type="checkbox" name="groupClients" value="${clientId}">
                    <span>${client.name} (${client.ip_address})</span>
                `;
                clientList.appendChild(label);
            });
        }

        // 그룹 폼 제출 처리
        document.getElementById('groupForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const name = document.getElementById('groupName').value.trim();
            const description = document.getElementById('groupDescription').value.trim();
            const selectedClients = Array.from(document.querySelectorAll('input[name="groupClients"]:checked'))
                .map(cb => cb.value);
            
            if (selectedClients.length === 0) {
                showToast('최소 하나 이상의 디스플레이 서버를 선택해주세요.', 'error');
                return;
            }
            
            // 중복 이름 체크
            const existingNames = Array.from(groups.values()).map(g => g.name);
            if (!editingGroupId && existingNames.includes(name)) {
                showToast('이미 존재하는 그룹 이름입니다.', 'error');
                return;
            }
            
            if (editingGroupId) {
                // 그룹 수정
                const group = groups.get(editingGroupId);
                group.name = name;
                group.description = description;
                group.client_ids = selectedClients;
                groups.set(editingGroupId, group);
                
                updateGroupInDOM(group);
                showToast(`그룹 "${name}"이(가) 수정되었습니다.`, 'success');
            } else {
                // 새 그룹 생성
                const groupId = `group_${Date.now()}`;
                const newGroup = {
                    id: groupId,
                    name: name,
                    description: description,
                    client_ids: selectedClients,
                    created_at: new Date()
                };
                
                groups.set(groupId, newGroup);
                addGroupToDOM(newGroup);
                showToast(`새 그룹 "${name}"이(가) 생성되었습니다.`, 'success');
            }
            
            updatePresetGroupList();
            updateAllStats();
            closeGroupModal();
        });

        function addGroupToDOM(group) {
            const groupGrid = document.getElementById('groupGrid');
            
            // 빈 상태 메시지 제거
            const emptyMessage = groupGrid.querySelector('[style*="grid-column"]');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            const groupElement = document.createElement('div');
            groupElement.className = 'group-card';
            groupElement.innerHTML = createGroupCardHTML(group);
            
            groupGrid.appendChild(groupElement);
        }

        function updateGroupInDOM(group) {
            const groupCard = document.querySelector(`[data-group-id="${group.id}"]`).closest('.group-card');
            if (groupCard) {
                groupCard.innerHTML = createGroupCardHTML(group);
            }
        }

        function createGroupCardHTML(group) {
            const clientTags = group.client_ids.map(clientId => {
                const client = clients.get(clientId);
                return client ? `<span class="client-tag">${client.ip_address}</span>` : '';
            }).join('');
            
            return `
                <input type="checkbox" class="group-checkbox" data-group-id="${group.id}" onclick="event.stopPropagation()" onchange="updateSelectedGroupCount()">
                <div class="group-content">
                    <div class="group-name">${group.name}</div>
                    <div class="group-info">${group.client_ids.length}개 디스플레이 서버</div>
                    <div class="group-clients">
                        ${clientTags}
                    </div>
                </div>
                <div class="group-actions">
                    <button class="btn btn-secondary" onclick="editGroup('${group.id}')" title="편집">✏️</button>
                    <button class="btn btn-danger" onclick="deleteGroup('${group.id}')" title="삭제">🗑️</button>
                </div>
            `;
        }

        function deleteGroup(groupId) {
            const group = groups.get(groupId);
            if (!group) return;
            
            if (confirm(`정말 "${group.name}" 그룹을 삭제하시겠습니까?\n그룹만 삭제되고 클라이언트는 유지됩니다.`)) {
                // DOM에서 제거
                const groupCard = document.querySelector(`[data-group-id="${groupId}"]`).closest('.group-card');
                if (groupCard) {
                    groupCard.remove();
                }
                
                // 데이터에서 제거
                groups.delete(groupId);
                
                // 선택된 항목에서 제거
                selectedGroups.delete(groupId);
                updateSelectedGroupCount();
                
                updatePresetGroupList();
                updateAllStats();
                
                showToast(`그룹 "${group.name}"이(가) 삭제되었습니다.`, 'error');
            }
        }

        // ==================== 프리셋 관리 ====================
        function showAddPresetModal() {
            editingPresetId = null;
            document.getElementById('presetModalTitle').textContent = '새 프리셋 만들기';
            document.getElementById('presetForm').reset();
            updatePresetGroupList();
            document.getElementById('presetModal').style.display = 'flex';
        }

        function editPreset(presetId) {
            editingPresetId = presetId;
            document.getElementById('presetModalTitle').textContent = '프리셋 편집';
            
            const preset = presets.get(presetId);
            if (preset) {
                document.getElementById('presetName').value = preset.name;
                document.getElementById('presetDescription').value = preset.description || '';
                document.getElementById('presetCommand').value = preset.command;
                
                updatePresetGroupList();
                
                // 기존 선택된 그룹 체크
                preset.group_ids.forEach(groupId => {
                    const checkbox = document.querySelector(`input[name="presetGroups"][value="${groupId}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }
            
            document.getElementById('presetModal').style.display = 'flex';
        }

        function closePresetModal() {
            document.getElementById('presetModal').style.display = 'none';
            document.getElementById('presetForm').reset();
            editingPresetId = null;
        }

        function updatePresetGroupList() {
            const groupList = document.getElementById('presetGroupList');
            
            if (groups.size === 0) {
                groupList.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                        먼저 그룹을 생성해주세요
                    </div>
                `;
                return;
            }
            
            groupList.innerHTML = '';
            groups.forEach((group, groupId) => {
                const label = document.createElement('label');
                label.className = 'checkbox-label';
                label.innerHTML = `
                    <input type="checkbox" name="presetGroups" value="${groupId}">
                    <span>${group.name} (${group.client_ids.length}개 클라이언트)</span>
                `;
                groupList.appendChild(label);
            });
        }

        // 프리셋 폼 제출 처리
        document.getElementById('presetForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const name = document.getElementById('presetName').value.trim();
            const description = document.getElementById('presetDescription').value.trim();
            const command = document.getElementById('presetCommand').value.trim();
            const selectedGroups = Array.from(document.querySelectorAll('input[name="presetGroups"]:checked'))
                .map(cb => cb.value);
            
            if (selectedGroups.length === 0) {
                showToast('최소 하나 이상의 그룹을 선택해주세요.', 'error');
                return;
            }
            
            // 중복 이름 체크
            const existingNames = Array.from(presets.values()).map(p => p.name);
            if (!editingPresetId && existingNames.includes(name)) {
                showToast('이미 존재하는 프리셋 이름입니다.', 'error');
                return;
            }
            
            if (editingPresetId) {
                // 프리셋 수정
                const preset = presets.get(editingPresetId);
                preset.name = name;
                preset.description = description;
                preset.command = command;
                preset.group_ids = selectedGroups;
                presets.set(editingPresetId, preset);
                
                updatePresetInDOM(preset);
                showToast(`프리셋 "${name}"이(가) 수정되었습니다.`, 'success');
            } else {
                // 새 프리셋 생성
                const presetId = `preset_${Date.now()}`;
                const newPreset = {
                    id: presetId,
                    name: name,
                    description: description,
                    command: command,
                    group_ids: selectedGroups,
                    created_at: new Date(),
                    is_active: false
                };
                
                presets.set(presetId, newPreset);
                addPresetToDOM(newPreset);
                showToast(`새 프리셋 "${name}"이(가) 생성되었습니다.`, 'success');
            }
            
            updateAllStats();
            closePresetModal();
        });

        function addPresetToDOM(preset) {
            const presetGrid = document.getElementById('presetGrid');
            
            // 빈 상태 메시지 제거
            const emptyMessage = presetGrid.querySelector('[style*="grid-column"]');
            if (emptyMessage) {
                emptyMessage.remove();
            }
            
            const presetElement = document.createElement('div');
            presetElement.className = 'preset-card';
            presetElement.id = `preset-${preset.id}`;
            presetElement.innerHTML = createPresetCardHTML(preset);
            
            presetGrid.appendChild(presetElement);
        }

        function updatePresetInDOM(preset) {
            const presetCard = document.getElementById(`preset-${preset.id}`);
            if (presetCard) {
                presetCard.innerHTML = createPresetCardHTML(preset);
            }
        }

        function createPresetCardHTML(preset) {
            const groupNames = preset.group_ids.map(groupId => {
                const group = groups.get(groupId);
                return group ? group.name : '삭제된 그룹';
            }).join(', ');
            
            return `
                <input type="checkbox" class="preset-checkbox" data-preset-id="${preset.id}" onclick="event.stopPropagation()" onchange="updateSelectedPresetCount()">
                <div class="preset-content">
                    <div class="preset-name">${preset.name}</div>
                    ${preset.description ? `<div class="preset-info">${preset.description}</div>` : ''}
                    <div class="preset-info">그룹: ${groupNames}</div>
                    <div class="preset-info">${preset.group_ids.length}개 그룹, ${getTotalClientsInGroups(preset.group_ids)}대 클라이언트</div>
                </div>
                <div class="preset-actions">
                    <button class="btn btn-primary" onclick="executePreset('${preset.id}')" title="실행">▶️</button>
                    <button class="btn btn-secondary" onclick="editPreset('${preset.id}')" title="편집">✏️</button>
                    <button class="btn btn-danger" onclick="deletePreset('${preset.id}')" title="삭제">🗑️</button>
                </div>
            `;
        }

        function getTotalClientsInGroups(groupIds) {
            const clientSet = new Set();
            groupIds.forEach(groupId => {
                const group = groups.get(groupId);
                if (group) {
                    group.client_ids.forEach(clientId => clientSet.add(clientId));
                }
            });
            return clientSet.size;
        }

        function executePreset(presetId) {
            const preset = presets.get(presetId);
            if (!preset) return;
            
            // 대상 클라이언트 수집
            const targetClients = new Set();
            preset.group_ids.forEach(groupId => {
                const group = groups.get(groupId);
                if (group) {
                    group.client_ids.forEach(clientId => {
                        const client = clients.get(clientId);
                        if (client && client.status !== 'offline') {
                            targetClients.add(clientId);
                        }
                    });
                }
            });
            
            if (targetClients.size === 0) {
                showToast('실행 가능한 온라인 클라이언트가 없습니다.', 'error');
                return;
            }
            
            // 실행 기록 생성
            const executionId = `exec_${Date.now()}`;
            const execution = {
                id: executionId,
                preset_id: presetId,
                preset_name: preset.name,
                target_clients: Array.from(targetClients),
                status: 'running',
                started_at: new Date(),
                completed_at: null,
                results: {}
            };
            
            // 각 클라이언트를 실행 중 상태로 변경
            targetClients.forEach(clientId => {
                updateClientStatus(clientId, 'running');
                execution.results[clientId] = 'running';
                addClientHistory(clientId, `프리셋 실행: ${preset.name}`);
                
                // 실행 ID 표시
                const clientElement = document.querySelector(`[data-client-id="${clientId}"]`);
                if (clientElement) {
                    let execIdElement = clientElement.querySelector('.execution-id');
                    if (!execIdElement) {
                        execIdElement = document.createElement('div');
                        execIdElement.className = 'execution-id';
                        clientElement.appendChild(execIdElement);
                    }
                    execIdElement.textContent = executionId.slice(-6);
                }
            });
            
            // 프리셋 카드 활성화
            const presetCard = document.getElementById(`preset-${presetId}`);
            presetCard.classList.add('active');
            preset.is_active = true;
            presets.set(presetId, preset);
            
            executions.set(executionId, execution);
            addExecutionToHistory(execution);
            
            showToast(`프리셋 "${preset.name}"이(가) ${targetClients.size}개 클라이언트에서 실행되었습니다.`, 'success');
            
            // 실행 완료 시뮬레이션 (10-30초 후)
            setTimeout(() => {
                completeExecution(executionId);
            }, Math.random() * 20000 + 10000);
            
            updateAllStats();
        }

        function completeExecution(executionId) {
            const execution = executions.get(executionId);
            if (!execution) return;
            
            execution.status = 'completed';
            execution.completed_at = new Date();
            
            // 클라이언트들을 온라인 상태로 변경
            execution.target_clients.forEach(clientId => {
                execution.results[clientId] = Math.random() > 0.1 ? 'success' : 'failed';
                updateClientStatus(clientId, 'online');
                addClientHistory(clientId, `프리셋 완료: ${execution.results[clientId]}`);
                
                // 실행 ID 제거
                const clientElement = document.querySelector(`[data-client-id="${clientId}"]`);
                if (clientElement) {
                    const execIdElement = clientElement.querySelector('.execution-id');
                    if (execIdElement) {
                        execIdElement.remove();
                    }
                }
            });
            
            // 프리셋 카드 비활성화
            const presetCard = document.getElementById(`preset-${execution.preset_id}`);
            if (presetCard) {
                presetCard.classList.remove('active');
            }
            
            const preset = presets.get(execution.preset_id);
            if (preset) {
                preset.is_active = false;
                presets.set(execution.preset_id, preset);
            }
            
            executions.set(executionId, execution);
            updateExecutionInHistory(execution);
            
            const successCount = Object.values(execution.results).filter(r => r === 'success').length;
            const failedCount = Object.values(execution.results).filter(r => r === 'failed').length;
            
            showToast(`프리셋 실행 완료: 성공 ${successCount}개, 실패 ${failedCount}개`, 
                     failedCount === 0 ? 'success' : 'warning');
            
            updateAllStats();
        }

        function deletePreset(presetId) {
            const preset = presets.get(presetId);
            if (!preset) return;
            
            if (confirm(`정말 "${preset.name}" 프리셋을 삭제하시겠습니까?\n실행 중인 경우 자동으로 중지됩니다.`)) {
                // 실행 중이면 중지
                if (preset.is_active) {
                    stopActiveExecutions(presetId);
                }
                
                // DOM에서 제거
                const presetCard = document.getElementById(`preset-${presetId}`);
                if (presetCard) {
                    presetCard.remove();
                }
                
                // 데이터에서 제거
                presets.delete(presetId);
                
                // 선택된 항목에서 제거
                selectedPresets.delete(presetId);
                updateSelectedPresetCount();
                
                updateAllStats();
                
                showToast(`프리셋 "${preset.name}"이(가) 삭제되었습니다.`, 'error');
            }
        }

        function stopActiveExecutions(presetId) {
            const activeExecutions = Array.from(executions.values()).filter(exec => 
                exec.preset_id === presetId && exec.status === 'running'
            );
            
            activeExecutions.forEach(execution => {
                execution.status = 'cancelled';
                execution.completed_at = new Date();
                
                execution.target_clients.forEach(clientId => {
                    execution.results[clientId] = 'cancelled';
                    updateClientStatus(clientId, 'online');
                    addClientHistory(clientId, '프리셋 실행 취소됨');
                    
                    // 실행 ID 제거
                    const clientElement = document.querySelector(`[data-client-id="${clientId}"]`);
                    if (clientElement) {
                        const execIdElement = clientElement.querySelector('.execution-id');
                        if (execIdElement) {
                            execIdElement.remove();
                        }
                    }
                });
                
                executions.set(execution.id, execution);
                updateExecutionInHistory(execution);
            });
        }

        // ==================== 실행 히스토리 관리 ====================
        function addExecutionToHistory(execution) {
            const executionMonitor = document.getElementById('executionMonitor');
            const executionList = document.getElementById('executionList');
            
            executionMonitor.style.display = 'block';
            
            const executionElement = document.createElement('div');
            executionElement.className = 'execution-item';
            executionElement.id = `execution-${execution.id}`;
            executionElement.innerHTML = createExecutionHTML(execution);
            
            executionList.insertBefore(executionElement, executionList.firstChild);
            
            // 최대 10개만 유지
            const executionItems = executionList.querySelectorAll('.execution-item');
            if (executionItems.length > 10) {
                executionItems[executionItems.length - 1].remove();
            }
        }

        function updateExecutionInHistory(execution) {
            const executionElement = document.getElementById(`execution-${execution.id}`);
            if (executionElement) {
                executionElement.innerHTML = createExecutionHTML(execution);
            }
        }

        function createExecutionHTML(execution) {
            const duration = execution.completed_at ? 
                Math.round((execution.completed_at - execution.started_at) / 1000) : 
                Math.round((new Date() - execution.started_at) / 1000);
            
            const successCount = Object.values(execution.results).filter(r => r === 'success').length;
            const failedCount = Object.values(execution.results).filter(r => r === 'failed').length;
            const runningCount = Object.values(execution.results).filter(r => r === 'running').length;
            
            const progress = execution.status === 'running' ? 
                Math.min(95, (duration / 30) * 100) : 100;
            
            return `
                <div class="execution-header">
                    <div>
                        <strong>${execution.preset_name}</strong>
                        <div class="execution-details">
                            ID: ${execution.id} | 시작: ${execution.started_at.toLocaleTimeString('ko-KR')}
                            ${execution.completed_at ? ` | 완료: ${execution.completed_at.toLocaleTimeString('ko-KR')}` : ''}
                            | 소요시간: ${duration}초
                        </div>
                    </div>
                    <span class="execution-status ${execution.status}">${getStatusText(execution.status)}</span>
                </div>
                <div class="execution-targets">
                    ${execution.target_clients.map(clientId => {
                        const client = clients.get(clientId);
                        const result = execution.results[clientId] || 'pending';
                        return `<span class="target-client ${result}">${client ? client.name : 'Unknown'}</span>`;
                    }).join('')}
                </div>
                <div class="execution-details">
                    성공: ${successCount}개 | 실패: ${failedCount}개 | 실행중: ${runningCount}개
                </div>
                ${execution.status === 'running' ? `
                    <div class="execution-progress">
                        <div class="execution-progress-bar" style="width: ${progress}%"></div>
                    </div>
                ` : ''}
            `;
        }

        // ==================== 일괄 제어 기능 ====================
        function toggleSelectAllPresets() {
            const selectAll = document.getElementById('selectAllPresets');
            const checkboxes = document.querySelectorAll('.preset-checkbox');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAll.checked;
            });
            
            updateSelectedPresetCount();
        }

        function toggleSelectAllGroups() {
            const selectAll = document.getElementById('selectAllGroups');
            const checkboxes = document.querySelectorAll('.group-checkbox');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAll.checked;
            });
            
            updateSelectedGroupCount();
        }

        function updateSelectedPresetCount() {
            const checkedBoxes = document.querySelectorAll('.preset-checkbox:checked');
            document.getElementById('selectedPresetCount').textContent = checkedBoxes.length;
            selectedPresets = new Set(Array.from(checkedBoxes).map(cb => cb.dataset.presetId));
        }

        function updateSelectedGroupCount() {
            const checkedBoxes = document.querySelectorAll('.group-checkbox:checked');
            document.getElementById('selectedGroupCount').textContent = checkedBoxes.length;
            selectedGroups = new Set(Array.from(checkedBoxes).map(cb => cb.dataset.groupId));
        }

        function bulkPresetAction(action) {
            if (selectedPresets.size === 0) {
                showToast('선택된 프리셋이 없습니다.', 'error');
                return;
            }
            
            const actionNames = {
                'execute': '실행',
                'stop': '정지', 
                'delete': '삭제'
            };
            
            const actionName = actionNames[action];
            const presetCount = selectedPresets.size;
            
            if (action === 'delete') {
                if (confirm(`선택된 ${presetCount}개 프리셋을 모두 삭제하시겠습니까?\n실행 중인 프리셋은 자동으로 중지됩니다.`)) {
                    selectedPresets.forEach(presetId => {
                        deletePreset(presetId);
                    });
                    
                    selectedPresets.clear();
                    document.getElementById('selectAllPresets').checked = false;
                    updateSelectedPresetCount();
                }
            } else if (action === 'execute') {
                if (confirm(`선택된 ${presetCount}개 프리셋을 모두 실행하시겠습니까?`)) {
                    let executed = 0;
                    selectedPresets.forEach(presetId => {
                        const preset = presets.get(presetId);
                        if (preset && !preset.is_active) {
                            executePreset(presetId);
                            executed++;
                        }
                    });
                    showToast(`${executed}개 프리셋이 실행되었습니다.`, 'success');
                }
            } else if (action === 'stop') {
                if (confirm(`선택된 ${presetCount}개 프리셋을 모두 정지하시겠습니까?`)) {
                    let stopped = 0;
                    selectedPresets.forEach(presetId => {
                        const preset = presets.get(presetId);
                        if (preset && preset.is_active) {
                            stopActiveExecutions(presetId);
                            stopped++;
                        }
                    });
                    showToast(`${stopped}개 프리셋이 정지되었습니다.`, 'success');
                }
            }
        }

        function bulkGroupAction(action) {
            if (selectedGroups.size === 0) {
                showToast('선택된 그룹이 없습니다.', 'error');
                return;
            }
            
            const actionNames = {
                'on': '켜기',
                'reboot': '재부팅',
                'off': '끄기'
            };
            
            const actionName = actionNames[action];
            const groupCount = selectedGroups.size;
            
            if (confirm(`선택된 ${groupCount}개 그룹의 모든 디스플레이 서버를 ${actionName} 하시겠습니까?`)) {
                let totalClients = 0;
                selectedGroups.forEach(groupId => {
                    const group = groups.get(groupId);
                    if (group) {
                        totalClients += group.client_ids.length;
                        group.client_ids.forEach(clientId => {
                            addClientHistory(clientId, `전원 ${actionName} 명령 수신`);
                        });
                    }
                });
                
                showToast(`${groupCount}개 그룹 (${totalClients}대 클라이언트)에 전원 ${actionName} 명령을 전송했습니다. (v2.1에서 활성화)`, 'info');
            }
        }

        // ==================== 토스트 및 모달 관리 ====================
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast';
            if (type) toast.classList.add(type);
            toast.style.display = 'block';
            
            setTimeout(() => {
                toast.style.display = 'none';
            }, 4000);
        }

        // 모달 외부 클릭 시 닫기
        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                if (event.target.id === 'clientModal') {
                    closeModal();
                } else if (event.target.id === 'presetModal') {
                    closePresetModal();
                } else if (event.target.id === 'groupModal') {
                    closeGroupModal();
                } else if (event.target.id === 'addClientModal') {
                    closeAddClientModal();
                }
            }
        };

        // ==================== Socket.io 이벤트 핸들러 (실제 구현용) ====================
        /*
        socket.on('connect', () => {
            isSocketConnected = true;
            updateSocketStatus();
            showToast('서버에 연결되었습니다.', 'success');
        });

        socket.on('disconnect', () => {
            isSocketConnected = false;
            updateSocketStatus();
            showToast('서버 연결이 끊어졌습니다.', 'error');
        });

        socket.on('client_registered', (data) => {
            const client = {
                id: data.id,
                name: data.name,
                ip_address: data.ip_address,
                port: data.port,
                status: 'online',
                created_at: new Date(),
                last_seen: new Date()
            };
            
            clients.set(data.id, client);
            addClientToDOM(client);
            addClientHistory(data.id, 'Python 클라이언트에서 자동 등록됨');
            updateGroupClientList();
            updateAllStats();
            
            showToast(`새 클라이언트 "${data.name}"이(가) 연결되었습니다.`, 'success');
        });

        socket.on('client_status_changed', (data) => {
            updateClientStatus(data.client_id, data.status);
            addClientHistory(data.client_id, `상태 변경: ${data.status}`);
        });

        socket.on('client_metrics_update', (data) => {
            updateClientMetrics(data.client_id);
        });

        socket.on('preset_execution_started', (data) => {
            const execution = {
                id: data.execution_id,
                preset_id: data.preset_id,
                preset_name: data.preset_name,
                target_clients: data.target_clients,
                status: 'running',
                started_at: new Date(data.started_at),
                results: data.results
            };
            
            executions.set(data.execution_id, execution);
            addExecutionToHistory(execution);
        });

        socket.on('preset_execution_updated', (data) => {
            const execution = executions.get(data.execution_id);
            if (execution) {
                execution.status = data.status;
                execution.results = data.results;
                if (data.completed_at) {
                    execution.completed_at = new Date(data.completed_at);
                }
                
                executions.set(data.execution_id, execution);
                updateExecutionInHistory(execution);
            }
        });

        socket.on('client_disconnected', (data) => {
            updateClientStatus(data.client_id, 'offline');
            addClientHistory(data.client_id, '연결 끊김');
        });

        socket.on('broadcast_notification', (data) => {
            showToast(data.message, data.type);
        });

        socket.on('broadcast_error', (data) => {
            showToast(`시스템 오류: ${data.message}`, 'error');
        });
        */

        // ==================== 데모 데이터 생성 (개발용) ====================
        function createDemoData() {
            // 데모 클라이언트 생성
            const demoClients = [
                { name: 'Display_01', ip: '192.168.1.101', status: 'online' },
                { name: 'Display_02', ip: '192.168.1.102', status: 'running' },
                { name: 'Display_03', ip: '192.168.1.103', status: 'offline' },
                { name: 'Display_04', ip: '192.168.1.104', status: 'online' }
            ];
            
            demoClients.forEach((clientData, index) => {
                const clientId = `demo_client_${index + 1}`;
                const client = {
                    id: clientId,
                    name: clientData.name,
                    ip_address: clientData.ip,
                    port: 8081,
                    description: `데모 클라이언트 ${index + 1}`,
                    status: clientData.status,
                    created_at: new Date(Date.now() - (index * 86400000)), // 하루씩 차이
                    last_seen: clientData.status !== 'offline' ? new Date() : null
                };
                
                clients.set(clientId, client);
                addClientToDOM(client);
                addClientHistory(clientId, '데모 데이터로 생성됨');
            });
            
            // 데모 그룹 생성
            setTimeout(() => {
                const groupId = 'demo_group_1';
                const group = {
                    id: groupId,
                    name: '메인 디스플레이 월',
                    description: '중앙 메인 디스플레이 구역',
                    client_ids: ['demo_client_1', 'demo_client_2', 'demo_client_4'],
                    created_at: new Date()
                };
                
                groups.set(groupId, group);
                addGroupToDOM(group);
                updateGroupClientList();
                updatePresetGroupList();
            }, 500);
            
            // 데모 프리셋 생성
            setTimeout(() => {
                const presetId = 'demo_preset_1';
                const preset = {
                    id: presetId,
                    name: '메인 콘텐츠 재생',
                    description: '4K 메인 콘텐츠 스트리밍',
                    command: 'D:\\UnrealProjects\\MainContent\\Windows\\MainContent.exe None -messaging -dc_cluster -nosplash -dc_cfg="C:\\nDisplay\\MainWall.ndisplay" -dc_node=Node_0 -fullscreen',
                    group_ids: ['demo_group_1'],
                    created_at: new Date(),
                    is_active: false
                };
                
                presets.set(presetId, preset);
                addPresetToDOM(preset);
            }, 1000);
            
            updateAllStats();
            showToast('데모 데이터가 로드되었습니다. 실제 환경에서는 서버와 연동됩니다.', 'info');
        }

        // 개발 모드에서 데모 데이터 생성
        setTimeout(() => {
            createDemoData();
        }, 3000);
    </script>
</body>
</html>
            